schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

input CanVoteInput {
  eventId: uuid
}

type CanVoteOutput {
  active: Boolean
  canVote: Boolean
  pollId: uuid!
}

"""
expression to compare columns of type Int. All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
expression to compare columns of type String. All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

input VoteInput {
  pollId: uuid
  value: [Int]
}

type VoteOutput {
  headers: String
  pollId: uuid!
}

scalar _int4

"""
expression to compare columns of type _int4. All fields are combined with logical 'AND'.
"""
input _int4_comparison_exp {
  _eq: _int4
  _gt: _int4
  _gte: _int4
  _in: [_int4!]
  _is_null: Boolean
  _lt: _int4
  _lte: _int4
  _neq: _int4
  _nin: [_int4!]
}

scalar _text

"""
expression to compare columns of type _text. All fields are combined with logical 'AND'.
"""
input _text_comparison_exp {
  _eq: _text
  _gt: _text
  _gte: _text
  _in: [_text!]
  _is_null: Boolean
  _lt: _text
  _lte: _text
  _neq: _text
  _nin: [_text!]
}

"""
columns and relationships of "admissions"
"""
type admissions {
  checkedIn: Boolean!
  email: String!

  """An object relationship"""
  event: events
  eventId: uuid!
  id: uuid!

  """An object relationship"""
  identity: identities
  voting: Boolean
}

"""
aggregated selection of "admissions"
"""
type admissions_aggregate {
  aggregate: admissions_aggregate_fields
  nodes: [admissions!]!
}

"""
aggregate fields of "admissions"
"""
type admissions_aggregate_fields {
  count(columns: [admissions_select_column!], distinct: Boolean): Int
  max: admissions_max_fields
  min: admissions_min_fields
}

"""
order by aggregate values of table "admissions"
"""
input admissions_aggregate_order_by {
  count: order_by
  max: admissions_max_order_by
  min: admissions_min_order_by
}

"""
input type for inserting array relation for remote table "admissions"
"""
input admissions_arr_rel_insert_input {
  data: [admissions_insert_input!]!
  on_conflict: admissions_on_conflict
}

"""
Boolean expression to filter rows from the table "admissions". All fields are combined with a logical 'AND'.
"""
input admissions_bool_exp {
  _and: [admissions_bool_exp]
  _not: admissions_bool_exp
  _or: [admissions_bool_exp]
  checkedIn: Boolean_comparison_exp
  email: String_comparison_exp
  event: events_bool_exp
  eventId: uuid_comparison_exp
  id: uuid_comparison_exp
  identity: identities_bool_exp
  voting: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "admissions"
"""
enum admissions_constraint {
  """unique or primary key constraint"""
  admissions_email_eventId_key

  """unique or primary key constraint"""
  admissions_pkey
}

"""
input type for inserting data into table "admissions"
"""
input admissions_insert_input {
  checkedIn: Boolean
  email: String
  event: events_obj_rel_insert_input
  eventId: uuid
  id: uuid
  identity: identities_obj_rel_insert_input
  voting: Boolean
}

"""aggregate max on columns"""
type admissions_max_fields {
  email: String
  eventId: uuid
  id: uuid
}

"""
order by max() on columns of table "admissions"
"""
input admissions_max_order_by {
  email: order_by
  eventId: order_by
  id: order_by
}

"""aggregate min on columns"""
type admissions_min_fields {
  email: String
  eventId: uuid
  id: uuid
}

"""
order by min() on columns of table "admissions"
"""
input admissions_min_order_by {
  email: order_by
  eventId: order_by
  id: order_by
}

"""
response of any mutation on the table "admissions"
"""
type admissions_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [admissions!]!
}

"""
input type for inserting object relation for remote table "admissions"
"""
input admissions_obj_rel_insert_input {
  data: admissions_insert_input!
  on_conflict: admissions_on_conflict
}

"""
on conflict condition type for table "admissions"
"""
input admissions_on_conflict {
  constraint: admissions_constraint!
  update_columns: [admissions_update_column!]!
  where: admissions_bool_exp
}

"""
ordering options when selecting data from "admissions"
"""
input admissions_order_by {
  checkedIn: order_by
  email: order_by
  event: events_order_by
  eventId: order_by
  id: order_by
  identity: identities_order_by
  voting: order_by
}

"""
primary key columns input for table: "admissions"
"""
input admissions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "admissions"
"""
enum admissions_select_column {
  """column name"""
  checkedIn

  """column name"""
  email

  """column name"""
  eventId

  """column name"""
  id

  """column name"""
  voting
}

"""
input type for updating data in table "admissions"
"""
input admissions_set_input {
  checkedIn: Boolean
  email: String
  eventId: uuid
  id: uuid
  voting: Boolean
}

"""
update columns of table "admissions"
"""
enum admissions_update_column {
  """column name"""
  checkedIn

  """column name"""
  email

  """column name"""
  eventId

  """column name"""
  id

  """column name"""
  voting
}

"""
columns and relationships of "auth.account_providers"
"""
type auth_account_providers {
  """An object relationship"""
  account: auth_accounts!
  account_id: uuid!
  auth_provider: String!
  auth_provider_unique_id: String!
  created_at: timestamptz!
  id: uuid!

  """An object relationship"""
  provider: auth_providers!
  updated_at: timestamptz!
}

"""
aggregated selection of "auth.account_providers"
"""
type auth_account_providers_aggregate {
  aggregate: auth_account_providers_aggregate_fields
  nodes: [auth_account_providers!]!
}

"""
aggregate fields of "auth.account_providers"
"""
type auth_account_providers_aggregate_fields {
  count(columns: [auth_account_providers_select_column!], distinct: Boolean): Int
  max: auth_account_providers_max_fields
  min: auth_account_providers_min_fields
}

"""
order by aggregate values of table "auth.account_providers"
"""
input auth_account_providers_aggregate_order_by {
  count: order_by
  max: auth_account_providers_max_order_by
  min: auth_account_providers_min_order_by
}

"""
input type for inserting array relation for remote table "auth.account_providers"
"""
input auth_account_providers_arr_rel_insert_input {
  data: [auth_account_providers_insert_input!]!
  on_conflict: auth_account_providers_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.account_providers". All fields are combined with a logical 'AND'.
"""
input auth_account_providers_bool_exp {
  _and: [auth_account_providers_bool_exp]
  _not: auth_account_providers_bool_exp
  _or: [auth_account_providers_bool_exp]
  account: auth_accounts_bool_exp
  account_id: uuid_comparison_exp
  auth_provider: String_comparison_exp
  auth_provider_unique_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  provider: auth_providers_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "auth.account_providers"
"""
enum auth_account_providers_constraint {
  """unique or primary key constraint"""
  account_providers_account_id_auth_provider_key

  """unique or primary key constraint"""
  account_providers_auth_provider_auth_provider_unique_id_key

  """unique or primary key constraint"""
  account_providers_pkey
}

"""
input type for inserting data into table "auth.account_providers"
"""
input auth_account_providers_insert_input {
  account: auth_accounts_obj_rel_insert_input
  account_id: uuid
  auth_provider: String
  auth_provider_unique_id: String
  created_at: timestamptz
  id: uuid
  provider: auth_providers_obj_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type auth_account_providers_max_fields {
  account_id: uuid
  auth_provider: String
  auth_provider_unique_id: String
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "auth.account_providers"
"""
input auth_account_providers_max_order_by {
  account_id: order_by
  auth_provider: order_by
  auth_provider_unique_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type auth_account_providers_min_fields {
  account_id: uuid
  auth_provider: String
  auth_provider_unique_id: String
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "auth.account_providers"
"""
input auth_account_providers_min_order_by {
  account_id: order_by
  auth_provider: order_by
  auth_provider_unique_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "auth.account_providers"
"""
type auth_account_providers_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [auth_account_providers!]!
}

"""
input type for inserting object relation for remote table "auth.account_providers"
"""
input auth_account_providers_obj_rel_insert_input {
  data: auth_account_providers_insert_input!
  on_conflict: auth_account_providers_on_conflict
}

"""
on conflict condition type for table "auth.account_providers"
"""
input auth_account_providers_on_conflict {
  constraint: auth_account_providers_constraint!
  update_columns: [auth_account_providers_update_column!]!
  where: auth_account_providers_bool_exp
}

"""
ordering options when selecting data from "auth.account_providers"
"""
input auth_account_providers_order_by {
  account: auth_accounts_order_by
  account_id: order_by
  auth_provider: order_by
  auth_provider_unique_id: order_by
  created_at: order_by
  id: order_by
  provider: auth_providers_order_by
  updated_at: order_by
}

"""
primary key columns input for table: "auth.account_providers"
"""
input auth_account_providers_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.account_providers"
"""
enum auth_account_providers_select_column {
  """column name"""
  account_id

  """column name"""
  auth_provider

  """column name"""
  auth_provider_unique_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at
}

"""
input type for updating data in table "auth.account_providers"
"""
input auth_account_providers_set_input {
  account_id: uuid
  auth_provider: String
  auth_provider_unique_id: String
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
update columns of table "auth.account_providers"
"""
enum auth_account_providers_update_column {
  """column name"""
  account_id

  """column name"""
  auth_provider

  """column name"""
  auth_provider_unique_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at
}

"""
columns and relationships of "auth.account_roles"
"""
type auth_account_roles {
  """An object relationship"""
  account: auth_accounts!
  account_id: uuid!
  created_at: timestamptz!
  id: uuid!
  role: String!

  """An object relationship"""
  roleByRole: auth_roles!
}

"""
aggregated selection of "auth.account_roles"
"""
type auth_account_roles_aggregate {
  aggregate: auth_account_roles_aggregate_fields
  nodes: [auth_account_roles!]!
}

"""
aggregate fields of "auth.account_roles"
"""
type auth_account_roles_aggregate_fields {
  count(columns: [auth_account_roles_select_column!], distinct: Boolean): Int
  max: auth_account_roles_max_fields
  min: auth_account_roles_min_fields
}

"""
order by aggregate values of table "auth.account_roles"
"""
input auth_account_roles_aggregate_order_by {
  count: order_by
  max: auth_account_roles_max_order_by
  min: auth_account_roles_min_order_by
}

"""
input type for inserting array relation for remote table "auth.account_roles"
"""
input auth_account_roles_arr_rel_insert_input {
  data: [auth_account_roles_insert_input!]!
  on_conflict: auth_account_roles_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.account_roles". All fields are combined with a logical 'AND'.
"""
input auth_account_roles_bool_exp {
  _and: [auth_account_roles_bool_exp]
  _not: auth_account_roles_bool_exp
  _or: [auth_account_roles_bool_exp]
  account: auth_accounts_bool_exp
  account_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  role: String_comparison_exp
  roleByRole: auth_roles_bool_exp
}

"""
unique or primary key constraints on table "auth.account_roles"
"""
enum auth_account_roles_constraint {
  """unique or primary key constraint"""
  account_roles_pkey

  """unique or primary key constraint"""
  user_roles_account_id_role_key
}

"""
input type for inserting data into table "auth.account_roles"
"""
input auth_account_roles_insert_input {
  account: auth_accounts_obj_rel_insert_input
  account_id: uuid
  created_at: timestamptz
  id: uuid
  role: String
  roleByRole: auth_roles_obj_rel_insert_input
}

"""aggregate max on columns"""
type auth_account_roles_max_fields {
  account_id: uuid
  created_at: timestamptz
  id: uuid
  role: String
}

"""
order by max() on columns of table "auth.account_roles"
"""
input auth_account_roles_max_order_by {
  account_id: order_by
  created_at: order_by
  id: order_by
  role: order_by
}

"""aggregate min on columns"""
type auth_account_roles_min_fields {
  account_id: uuid
  created_at: timestamptz
  id: uuid
  role: String
}

"""
order by min() on columns of table "auth.account_roles"
"""
input auth_account_roles_min_order_by {
  account_id: order_by
  created_at: order_by
  id: order_by
  role: order_by
}

"""
response of any mutation on the table "auth.account_roles"
"""
type auth_account_roles_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [auth_account_roles!]!
}

"""
input type for inserting object relation for remote table "auth.account_roles"
"""
input auth_account_roles_obj_rel_insert_input {
  data: auth_account_roles_insert_input!
  on_conflict: auth_account_roles_on_conflict
}

"""
on conflict condition type for table "auth.account_roles"
"""
input auth_account_roles_on_conflict {
  constraint: auth_account_roles_constraint!
  update_columns: [auth_account_roles_update_column!]!
  where: auth_account_roles_bool_exp
}

"""
ordering options when selecting data from "auth.account_roles"
"""
input auth_account_roles_order_by {
  account: auth_accounts_order_by
  account_id: order_by
  created_at: order_by
  id: order_by
  role: order_by
  roleByRole: auth_roles_order_by
}

"""
primary key columns input for table: "auth.account_roles"
"""
input auth_account_roles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.account_roles"
"""
enum auth_account_roles_select_column {
  """column name"""
  account_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  role
}

"""
input type for updating data in table "auth.account_roles"
"""
input auth_account_roles_set_input {
  account_id: uuid
  created_at: timestamptz
  id: uuid
  role: String
}

"""
update columns of table "auth.account_roles"
"""
enum auth_account_roles_update_column {
  """column name"""
  account_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  role
}

"""
columns and relationships of "auth.accounts"
"""
type auth_accounts {
  """An array relationship"""
  account_providers(
    """distinct select on columns"""
    distinct_on: [auth_account_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_providers_order_by!]

    """filter the rows returned"""
    where: auth_account_providers_bool_exp
  ): [auth_account_providers!]!

  """An aggregated array relationship"""
  account_providers_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_account_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_providers_order_by!]

    """filter the rows returned"""
    where: auth_account_providers_bool_exp
  ): auth_account_providers_aggregate!

  """An array relationship"""
  account_roles(
    """distinct select on columns"""
    distinct_on: [auth_account_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_roles_order_by!]

    """filter the rows returned"""
    where: auth_account_roles_bool_exp
  ): [auth_account_roles!]!

  """An aggregated array relationship"""
  account_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_account_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_roles_order_by!]

    """filter the rows returned"""
    where: auth_account_roles_bool_exp
  ): auth_account_roles_aggregate!
  active: Boolean!
  created_at: timestamptz!
  custom_register_data(
    """JSON select path"""
    path: String
  ): jsonb
  default_role: String!
  email: citext
  id: uuid!
  is_anonymous: Boolean!
  mfa_enabled: Boolean!
  new_email: citext
  otp_secret: String
  password_hash: String

  """An array relationship"""
  refresh_tokens(
    """distinct select on columns"""
    distinct_on: [auth_refresh_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_refresh_tokens_order_by!]

    """filter the rows returned"""
    where: auth_refresh_tokens_bool_exp
  ): [auth_refresh_tokens!]!

  """An aggregated array relationship"""
  refresh_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_refresh_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_refresh_tokens_order_by!]

    """filter the rows returned"""
    where: auth_refresh_tokens_bool_exp
  ): auth_refresh_tokens_aggregate!

  """An object relationship"""
  role: auth_roles!
  ticket: uuid!
  ticket_expires_at: timestamptz!
  updated_at: timestamptz!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "auth.accounts"
"""
type auth_accounts_aggregate {
  aggregate: auth_accounts_aggregate_fields
  nodes: [auth_accounts!]!
}

"""
aggregate fields of "auth.accounts"
"""
type auth_accounts_aggregate_fields {
  count(columns: [auth_accounts_select_column!], distinct: Boolean): Int
  max: auth_accounts_max_fields
  min: auth_accounts_min_fields
}

"""
order by aggregate values of table "auth.accounts"
"""
input auth_accounts_aggregate_order_by {
  count: order_by
  max: auth_accounts_max_order_by
  min: auth_accounts_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input auth_accounts_append_input {
  custom_register_data: jsonb
}

"""
input type for inserting array relation for remote table "auth.accounts"
"""
input auth_accounts_arr_rel_insert_input {
  data: [auth_accounts_insert_input!]!
  on_conflict: auth_accounts_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.accounts". All fields are combined with a logical 'AND'.
"""
input auth_accounts_bool_exp {
  _and: [auth_accounts_bool_exp]
  _not: auth_accounts_bool_exp
  _or: [auth_accounts_bool_exp]
  account_providers: auth_account_providers_bool_exp
  account_roles: auth_account_roles_bool_exp
  active: Boolean_comparison_exp
  created_at: timestamptz_comparison_exp
  custom_register_data: jsonb_comparison_exp
  default_role: String_comparison_exp
  email: citext_comparison_exp
  id: uuid_comparison_exp
  is_anonymous: Boolean_comparison_exp
  mfa_enabled: Boolean_comparison_exp
  new_email: citext_comparison_exp
  otp_secret: String_comparison_exp
  password_hash: String_comparison_exp
  refresh_tokens: auth_refresh_tokens_bool_exp
  role: auth_roles_bool_exp
  ticket: uuid_comparison_exp
  ticket_expires_at: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.accounts"
"""
enum auth_accounts_constraint {
  """unique or primary key constraint"""
  accounts_email_key

  """unique or primary key constraint"""
  accounts_new_email_key

  """unique or primary key constraint"""
  accounts_pkey

  """unique or primary key constraint"""
  accounts_user_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input auth_accounts_delete_at_path_input {
  custom_register_data: [String]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input auth_accounts_delete_elem_input {
  custom_register_data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input auth_accounts_delete_key_input {
  custom_register_data: String
}

"""
input type for inserting data into table "auth.accounts"
"""
input auth_accounts_insert_input {
  account_providers: auth_account_providers_arr_rel_insert_input
  account_roles: auth_account_roles_arr_rel_insert_input
  active: Boolean
  created_at: timestamptz
  custom_register_data: jsonb
  default_role: String
  email: citext
  id: uuid
  is_anonymous: Boolean
  mfa_enabled: Boolean
  new_email: citext
  otp_secret: String
  password_hash: String
  refresh_tokens: auth_refresh_tokens_arr_rel_insert_input
  role: auth_roles_obj_rel_insert_input
  ticket: uuid
  ticket_expires_at: timestamptz
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type auth_accounts_max_fields {
  created_at: timestamptz
  default_role: String
  email: citext
  id: uuid
  new_email: citext
  otp_secret: String
  password_hash: String
  ticket: uuid
  ticket_expires_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "auth.accounts"
"""
input auth_accounts_max_order_by {
  created_at: order_by
  default_role: order_by
  email: order_by
  id: order_by
  new_email: order_by
  otp_secret: order_by
  password_hash: order_by
  ticket: order_by
  ticket_expires_at: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type auth_accounts_min_fields {
  created_at: timestamptz
  default_role: String
  email: citext
  id: uuid
  new_email: citext
  otp_secret: String
  password_hash: String
  ticket: uuid
  ticket_expires_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "auth.accounts"
"""
input auth_accounts_min_order_by {
  created_at: order_by
  default_role: order_by
  email: order_by
  id: order_by
  new_email: order_by
  otp_secret: order_by
  password_hash: order_by
  ticket: order_by
  ticket_expires_at: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "auth.accounts"
"""
type auth_accounts_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [auth_accounts!]!
}

"""
input type for inserting object relation for remote table "auth.accounts"
"""
input auth_accounts_obj_rel_insert_input {
  data: auth_accounts_insert_input!
  on_conflict: auth_accounts_on_conflict
}

"""
on conflict condition type for table "auth.accounts"
"""
input auth_accounts_on_conflict {
  constraint: auth_accounts_constraint!
  update_columns: [auth_accounts_update_column!]!
  where: auth_accounts_bool_exp
}

"""
ordering options when selecting data from "auth.accounts"
"""
input auth_accounts_order_by {
  account_providers_aggregate: auth_account_providers_aggregate_order_by
  account_roles_aggregate: auth_account_roles_aggregate_order_by
  active: order_by
  created_at: order_by
  custom_register_data: order_by
  default_role: order_by
  email: order_by
  id: order_by
  is_anonymous: order_by
  mfa_enabled: order_by
  new_email: order_by
  otp_secret: order_by
  password_hash: order_by
  refresh_tokens_aggregate: auth_refresh_tokens_aggregate_order_by
  role: auth_roles_order_by
  ticket: order_by
  ticket_expires_at: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""
primary key columns input for table: "auth.accounts"
"""
input auth_accounts_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input auth_accounts_prepend_input {
  custom_register_data: jsonb
}

"""
select columns of table "auth.accounts"
"""
enum auth_accounts_select_column {
  """column name"""
  active

  """column name"""
  created_at

  """column name"""
  custom_register_data

  """column name"""
  default_role

  """column name"""
  email

  """column name"""
  id

  """column name"""
  is_anonymous

  """column name"""
  mfa_enabled

  """column name"""
  new_email

  """column name"""
  otp_secret

  """column name"""
  password_hash

  """column name"""
  ticket

  """column name"""
  ticket_expires_at

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "auth.accounts"
"""
input auth_accounts_set_input {
  active: Boolean
  created_at: timestamptz
  custom_register_data: jsonb
  default_role: String
  email: citext
  id: uuid
  is_anonymous: Boolean
  mfa_enabled: Boolean
  new_email: citext
  otp_secret: String
  password_hash: String
  ticket: uuid
  ticket_expires_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "auth.accounts"
"""
enum auth_accounts_update_column {
  """column name"""
  active

  """column name"""
  created_at

  """column name"""
  custom_register_data

  """column name"""
  default_role

  """column name"""
  email

  """column name"""
  id

  """column name"""
  is_anonymous

  """column name"""
  mfa_enabled

  """column name"""
  new_email

  """column name"""
  otp_secret

  """column name"""
  password_hash

  """column name"""
  ticket

  """column name"""
  ticket_expires_at

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
columns and relationships of "auth.providers"
"""
type auth_providers {
  """An array relationship"""
  account_providers(
    """distinct select on columns"""
    distinct_on: [auth_account_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_providers_order_by!]

    """filter the rows returned"""
    where: auth_account_providers_bool_exp
  ): [auth_account_providers!]!

  """An aggregated array relationship"""
  account_providers_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_account_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_providers_order_by!]

    """filter the rows returned"""
    where: auth_account_providers_bool_exp
  ): auth_account_providers_aggregate!
  provider: String!
}

"""
aggregated selection of "auth.providers"
"""
type auth_providers_aggregate {
  aggregate: auth_providers_aggregate_fields
  nodes: [auth_providers!]!
}

"""
aggregate fields of "auth.providers"
"""
type auth_providers_aggregate_fields {
  count(columns: [auth_providers_select_column!], distinct: Boolean): Int
  max: auth_providers_max_fields
  min: auth_providers_min_fields
}

"""
order by aggregate values of table "auth.providers"
"""
input auth_providers_aggregate_order_by {
  count: order_by
  max: auth_providers_max_order_by
  min: auth_providers_min_order_by
}

"""
input type for inserting array relation for remote table "auth.providers"
"""
input auth_providers_arr_rel_insert_input {
  data: [auth_providers_insert_input!]!
  on_conflict: auth_providers_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.providers". All fields are combined with a logical 'AND'.
"""
input auth_providers_bool_exp {
  _and: [auth_providers_bool_exp]
  _not: auth_providers_bool_exp
  _or: [auth_providers_bool_exp]
  account_providers: auth_account_providers_bool_exp
  provider: String_comparison_exp
}

"""
unique or primary key constraints on table "auth.providers"
"""
enum auth_providers_constraint {
  """unique or primary key constraint"""
  providers_pkey
}

"""
input type for inserting data into table "auth.providers"
"""
input auth_providers_insert_input {
  account_providers: auth_account_providers_arr_rel_insert_input
  provider: String
}

"""aggregate max on columns"""
type auth_providers_max_fields {
  provider: String
}

"""
order by max() on columns of table "auth.providers"
"""
input auth_providers_max_order_by {
  provider: order_by
}

"""aggregate min on columns"""
type auth_providers_min_fields {
  provider: String
}

"""
order by min() on columns of table "auth.providers"
"""
input auth_providers_min_order_by {
  provider: order_by
}

"""
response of any mutation on the table "auth.providers"
"""
type auth_providers_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [auth_providers!]!
}

"""
input type for inserting object relation for remote table "auth.providers"
"""
input auth_providers_obj_rel_insert_input {
  data: auth_providers_insert_input!
  on_conflict: auth_providers_on_conflict
}

"""
on conflict condition type for table "auth.providers"
"""
input auth_providers_on_conflict {
  constraint: auth_providers_constraint!
  update_columns: [auth_providers_update_column!]!
  where: auth_providers_bool_exp
}

"""
ordering options when selecting data from "auth.providers"
"""
input auth_providers_order_by {
  account_providers_aggregate: auth_account_providers_aggregate_order_by
  provider: order_by
}

"""
primary key columns input for table: "auth.providers"
"""
input auth_providers_pk_columns_input {
  provider: String!
}

"""
select columns of table "auth.providers"
"""
enum auth_providers_select_column {
  """column name"""
  provider
}

"""
input type for updating data in table "auth.providers"
"""
input auth_providers_set_input {
  provider: String
}

"""
update columns of table "auth.providers"
"""
enum auth_providers_update_column {
  """column name"""
  provider
}

"""
columns and relationships of "auth.refresh_tokens"
"""
type auth_refresh_tokens {
  """An object relationship"""
  account: auth_accounts!
  account_id: uuid!
  created_at: timestamptz!
  expires_at: timestamptz!
  refresh_token: uuid!
}

"""
aggregated selection of "auth.refresh_tokens"
"""
type auth_refresh_tokens_aggregate {
  aggregate: auth_refresh_tokens_aggregate_fields
  nodes: [auth_refresh_tokens!]!
}

"""
aggregate fields of "auth.refresh_tokens"
"""
type auth_refresh_tokens_aggregate_fields {
  count(columns: [auth_refresh_tokens_select_column!], distinct: Boolean): Int
  max: auth_refresh_tokens_max_fields
  min: auth_refresh_tokens_min_fields
}

"""
order by aggregate values of table "auth.refresh_tokens"
"""
input auth_refresh_tokens_aggregate_order_by {
  count: order_by
  max: auth_refresh_tokens_max_order_by
  min: auth_refresh_tokens_min_order_by
}

"""
input type for inserting array relation for remote table "auth.refresh_tokens"
"""
input auth_refresh_tokens_arr_rel_insert_input {
  data: [auth_refresh_tokens_insert_input!]!
  on_conflict: auth_refresh_tokens_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.refresh_tokens". All fields are combined with a logical 'AND'.
"""
input auth_refresh_tokens_bool_exp {
  _and: [auth_refresh_tokens_bool_exp]
  _not: auth_refresh_tokens_bool_exp
  _or: [auth_refresh_tokens_bool_exp]
  account: auth_accounts_bool_exp
  account_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  expires_at: timestamptz_comparison_exp
  refresh_token: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.refresh_tokens"
"""
enum auth_refresh_tokens_constraint {
  """unique or primary key constraint"""
  refresh_tokens_pkey
}

"""
input type for inserting data into table "auth.refresh_tokens"
"""
input auth_refresh_tokens_insert_input {
  account: auth_accounts_obj_rel_insert_input
  account_id: uuid
  created_at: timestamptz
  expires_at: timestamptz
  refresh_token: uuid
}

"""aggregate max on columns"""
type auth_refresh_tokens_max_fields {
  account_id: uuid
  created_at: timestamptz
  expires_at: timestamptz
  refresh_token: uuid
}

"""
order by max() on columns of table "auth.refresh_tokens"
"""
input auth_refresh_tokens_max_order_by {
  account_id: order_by
  created_at: order_by
  expires_at: order_by
  refresh_token: order_by
}

"""aggregate min on columns"""
type auth_refresh_tokens_min_fields {
  account_id: uuid
  created_at: timestamptz
  expires_at: timestamptz
  refresh_token: uuid
}

"""
order by min() on columns of table "auth.refresh_tokens"
"""
input auth_refresh_tokens_min_order_by {
  account_id: order_by
  created_at: order_by
  expires_at: order_by
  refresh_token: order_by
}

"""
response of any mutation on the table "auth.refresh_tokens"
"""
type auth_refresh_tokens_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [auth_refresh_tokens!]!
}

"""
input type for inserting object relation for remote table "auth.refresh_tokens"
"""
input auth_refresh_tokens_obj_rel_insert_input {
  data: auth_refresh_tokens_insert_input!
  on_conflict: auth_refresh_tokens_on_conflict
}

"""
on conflict condition type for table "auth.refresh_tokens"
"""
input auth_refresh_tokens_on_conflict {
  constraint: auth_refresh_tokens_constraint!
  update_columns: [auth_refresh_tokens_update_column!]!
  where: auth_refresh_tokens_bool_exp
}

"""
ordering options when selecting data from "auth.refresh_tokens"
"""
input auth_refresh_tokens_order_by {
  account: auth_accounts_order_by
  account_id: order_by
  created_at: order_by
  expires_at: order_by
  refresh_token: order_by
}

"""
primary key columns input for table: "auth.refresh_tokens"
"""
input auth_refresh_tokens_pk_columns_input {
  refresh_token: uuid!
}

"""
select columns of table "auth.refresh_tokens"
"""
enum auth_refresh_tokens_select_column {
  """column name"""
  account_id

  """column name"""
  created_at

  """column name"""
  expires_at

  """column name"""
  refresh_token
}

"""
input type for updating data in table "auth.refresh_tokens"
"""
input auth_refresh_tokens_set_input {
  account_id: uuid
  created_at: timestamptz
  expires_at: timestamptz
  refresh_token: uuid
}

"""
update columns of table "auth.refresh_tokens"
"""
enum auth_refresh_tokens_update_column {
  """column name"""
  account_id

  """column name"""
  created_at

  """column name"""
  expires_at

  """column name"""
  refresh_token
}

"""
columns and relationships of "auth.roles"
"""
type auth_roles {
  """An array relationship"""
  account_roles(
    """distinct select on columns"""
    distinct_on: [auth_account_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_roles_order_by!]

    """filter the rows returned"""
    where: auth_account_roles_bool_exp
  ): [auth_account_roles!]!

  """An aggregated array relationship"""
  account_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_account_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_roles_order_by!]

    """filter the rows returned"""
    where: auth_account_roles_bool_exp
  ): auth_account_roles_aggregate!

  """An array relationship"""
  accounts(
    """distinct select on columns"""
    distinct_on: [auth_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_accounts_order_by!]

    """filter the rows returned"""
    where: auth_accounts_bool_exp
  ): [auth_accounts!]!

  """An aggregated array relationship"""
  accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_accounts_order_by!]

    """filter the rows returned"""
    where: auth_accounts_bool_exp
  ): auth_accounts_aggregate!
  role: String!
}

"""
aggregated selection of "auth.roles"
"""
type auth_roles_aggregate {
  aggregate: auth_roles_aggregate_fields
  nodes: [auth_roles!]!
}

"""
aggregate fields of "auth.roles"
"""
type auth_roles_aggregate_fields {
  count(columns: [auth_roles_select_column!], distinct: Boolean): Int
  max: auth_roles_max_fields
  min: auth_roles_min_fields
}

"""
order by aggregate values of table "auth.roles"
"""
input auth_roles_aggregate_order_by {
  count: order_by
  max: auth_roles_max_order_by
  min: auth_roles_min_order_by
}

"""
input type for inserting array relation for remote table "auth.roles"
"""
input auth_roles_arr_rel_insert_input {
  data: [auth_roles_insert_input!]!
  on_conflict: auth_roles_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.roles". All fields are combined with a logical 'AND'.
"""
input auth_roles_bool_exp {
  _and: [auth_roles_bool_exp]
  _not: auth_roles_bool_exp
  _or: [auth_roles_bool_exp]
  account_roles: auth_account_roles_bool_exp
  accounts: auth_accounts_bool_exp
  role: String_comparison_exp
}

"""
unique or primary key constraints on table "auth.roles"
"""
enum auth_roles_constraint {
  """unique or primary key constraint"""
  roles_pkey
}

"""
input type for inserting data into table "auth.roles"
"""
input auth_roles_insert_input {
  account_roles: auth_account_roles_arr_rel_insert_input
  accounts: auth_accounts_arr_rel_insert_input
  role: String
}

"""aggregate max on columns"""
type auth_roles_max_fields {
  role: String
}

"""
order by max() on columns of table "auth.roles"
"""
input auth_roles_max_order_by {
  role: order_by
}

"""aggregate min on columns"""
type auth_roles_min_fields {
  role: String
}

"""
order by min() on columns of table "auth.roles"
"""
input auth_roles_min_order_by {
  role: order_by
}

"""
response of any mutation on the table "auth.roles"
"""
type auth_roles_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [auth_roles!]!
}

"""
input type for inserting object relation for remote table "auth.roles"
"""
input auth_roles_obj_rel_insert_input {
  data: auth_roles_insert_input!
  on_conflict: auth_roles_on_conflict
}

"""
on conflict condition type for table "auth.roles"
"""
input auth_roles_on_conflict {
  constraint: auth_roles_constraint!
  update_columns: [auth_roles_update_column!]!
  where: auth_roles_bool_exp
}

"""
ordering options when selecting data from "auth.roles"
"""
input auth_roles_order_by {
  account_roles_aggregate: auth_account_roles_aggregate_order_by
  accounts_aggregate: auth_accounts_aggregate_order_by
  role: order_by
}

"""
primary key columns input for table: "auth.roles"
"""
input auth_roles_pk_columns_input {
  role: String!
}

"""
select columns of table "auth.roles"
"""
enum auth_roles_select_column {
  """column name"""
  role
}

"""
input type for updating data in table "auth.roles"
"""
input auth_roles_set_input {
  role: String
}

"""
update columns of table "auth.roles"
"""
enum auth_roles_update_column {
  """column name"""
  role
}

"""
columns and relationships of "authorships"
"""
type authorships {
  """An object relationship"""
  content: contents
  contentId: uuid!
  email: String
  id: uuid!

  """An object relationship"""
  identity: identities
  name: String
}

"""
aggregated selection of "authorships"
"""
type authorships_aggregate {
  aggregate: authorships_aggregate_fields
  nodes: [authorships!]!
}

"""
aggregate fields of "authorships"
"""
type authorships_aggregate_fields {
  count(columns: [authorships_select_column!], distinct: Boolean): Int
  max: authorships_max_fields
  min: authorships_min_fields
}

"""
order by aggregate values of table "authorships"
"""
input authorships_aggregate_order_by {
  count: order_by
  max: authorships_max_order_by
  min: authorships_min_order_by
}

"""
input type for inserting array relation for remote table "authorships"
"""
input authorships_arr_rel_insert_input {
  data: [authorships_insert_input!]!
  on_conflict: authorships_on_conflict
}

"""
Boolean expression to filter rows from the table "authorships". All fields are combined with a logical 'AND'.
"""
input authorships_bool_exp {
  _and: [authorships_bool_exp]
  _not: authorships_bool_exp
  _or: [authorships_bool_exp]
  content: contents_bool_exp
  contentId: uuid_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  identity: identities_bool_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "authorships"
"""
enum authorships_constraint {
  """unique or primary key constraint"""
  authorships_pkey
}

"""
input type for inserting data into table "authorships"
"""
input authorships_insert_input {
  content: contents_obj_rel_insert_input
  contentId: uuid
  email: String
  id: uuid
  identity: identities_obj_rel_insert_input
  name: String
}

"""aggregate max on columns"""
type authorships_max_fields {
  contentId: uuid
  email: String
  id: uuid
  name: String
}

"""
order by max() on columns of table "authorships"
"""
input authorships_max_order_by {
  contentId: order_by
  email: order_by
  id: order_by
  name: order_by
}

"""aggregate min on columns"""
type authorships_min_fields {
  contentId: uuid
  email: String
  id: uuid
  name: String
}

"""
order by min() on columns of table "authorships"
"""
input authorships_min_order_by {
  contentId: order_by
  email: order_by
  id: order_by
  name: order_by
}

"""
response of any mutation on the table "authorships"
"""
type authorships_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [authorships!]!
}

"""
input type for inserting object relation for remote table "authorships"
"""
input authorships_obj_rel_insert_input {
  data: authorships_insert_input!
  on_conflict: authorships_on_conflict
}

"""
on conflict condition type for table "authorships"
"""
input authorships_on_conflict {
  constraint: authorships_constraint!
  update_columns: [authorships_update_column!]!
  where: authorships_bool_exp
}

"""
ordering options when selecting data from "authorships"
"""
input authorships_order_by {
  content: contents_order_by
  contentId: order_by
  email: order_by
  id: order_by
  identity: identities_order_by
  name: order_by
}

"""
primary key columns input for table: "authorships"
"""
input authorships_pk_columns_input {
  id: uuid!
}

"""
select columns of table "authorships"
"""
enum authorships_select_column {
  """column name"""
  contentId

  """column name"""
  email

  """column name"""
  id

  """column name"""
  name
}

"""
input type for updating data in table "authorships"
"""
input authorships_set_input {
  contentId: uuid
  email: String
  id: uuid
  name: String
}

"""
update columns of table "authorships"
"""
enum authorships_update_column {
  """column name"""
  contentId

  """column name"""
  email

  """column name"""
  id

  """column name"""
  name
}

scalar citext

"""
expression to compare columns of type citext. All fields are combined with logical 'AND'.
"""
input citext_comparison_exp {
  _eq: citext
  _gt: citext
  _gte: citext
  _ilike: String
  _in: [citext!]
  _is_null: Boolean
  _like: String
  _lt: citext
  _lte: citext
  _neq: citext
  _nilike: String
  _nin: [citext!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

"""
columns and relationships of "contents"
"""
type contents {
  """An array relationship"""
  authors(
    """distinct select on columns"""
    distinct_on: [authorships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authorships_order_by!]

    """filter the rows returned"""
    where: authorships_bool_exp
  ): [authorships!]!

  """An aggregated array relationship"""
  authors_aggregate(
    """distinct select on columns"""
    distinct_on: [authorships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authorships_order_by!]

    """filter the rows returned"""
    where: authorships_bool_exp
  ): authorships_aggregate!

  """An array relationship"""
  children(
    """distinct select on columns"""
    distinct_on: [contents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contents_order_by!]

    """filter the rows returned"""
    where: contents_bool_exp
  ): [contents!]!

  """An aggregated array relationship"""
  children_aggregate(
    """distinct select on columns"""
    distinct_on: [contents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contents_order_by!]

    """filter the rows returned"""
    where: contents_bool_exp
  ): contents_aggregate!
  createdAt: timestamptz

  """An object relationship"""
  creator: users
  creatorId: uuid!
  data: String!

  """An object relationship"""
  file: files
  fileId: uuid

  """An object relationship"""
  folder: folders
  folderId: uuid!
  id: uuid!
  name: String!

  """An object relationship"""
  parent: contents
  parentId: uuid

  """An array relationship"""
  polls(
    """distinct select on columns"""
    distinct_on: [polls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [polls_order_by!]

    """filter the rows returned"""
    where: polls_bool_exp
  ): [polls!]!

  """An aggregated array relationship"""
  polls_aggregate(
    """distinct select on columns"""
    distinct_on: [polls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [polls_order_by!]

    """filter the rows returned"""
    where: polls_bool_exp
  ): polls_aggregate!
  priority: Int!
  published: Boolean!
  updatedAt: timestamptz
}

"""
aggregated selection of "contents"
"""
type contents_aggregate {
  aggregate: contents_aggregate_fields
  nodes: [contents!]!
}

"""
aggregate fields of "contents"
"""
type contents_aggregate_fields {
  avg: contents_avg_fields
  count(columns: [contents_select_column!], distinct: Boolean): Int
  max: contents_max_fields
  min: contents_min_fields
  stddev: contents_stddev_fields
  stddev_pop: contents_stddev_pop_fields
  stddev_samp: contents_stddev_samp_fields
  sum: contents_sum_fields
  var_pop: contents_var_pop_fields
  var_samp: contents_var_samp_fields
  variance: contents_variance_fields
}

"""
order by aggregate values of table "contents"
"""
input contents_aggregate_order_by {
  avg: contents_avg_order_by
  count: order_by
  max: contents_max_order_by
  min: contents_min_order_by
  stddev: contents_stddev_order_by
  stddev_pop: contents_stddev_pop_order_by
  stddev_samp: contents_stddev_samp_order_by
  sum: contents_sum_order_by
  var_pop: contents_var_pop_order_by
  var_samp: contents_var_samp_order_by
  variance: contents_variance_order_by
}

"""
input type for inserting array relation for remote table "contents"
"""
input contents_arr_rel_insert_input {
  data: [contents_insert_input!]!
  on_conflict: contents_on_conflict
}

"""aggregate avg on columns"""
type contents_avg_fields {
  priority: Float
}

"""
order by avg() on columns of table "contents"
"""
input contents_avg_order_by {
  priority: order_by
}

"""
Boolean expression to filter rows from the table "contents". All fields are combined with a logical 'AND'.
"""
input contents_bool_exp {
  _and: [contents_bool_exp]
  _not: contents_bool_exp
  _or: [contents_bool_exp]
  authors: authorships_bool_exp
  children: contents_bool_exp
  createdAt: timestamptz_comparison_exp
  creator: users_bool_exp
  creatorId: uuid_comparison_exp
  data: String_comparison_exp
  file: files_bool_exp
  fileId: uuid_comparison_exp
  folder: folders_bool_exp
  folderId: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  parent: contents_bool_exp
  parentId: uuid_comparison_exp
  polls: polls_bool_exp
  priority: Int_comparison_exp
  published: Boolean_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "contents"
"""
enum contents_constraint {
  """unique or primary key constraint"""
  contents_pkey
}

"""
input type for incrementing integer column in table "contents"
"""
input contents_inc_input {
  priority: Int
}

"""
input type for inserting data into table "contents"
"""
input contents_insert_input {
  authors: authorships_arr_rel_insert_input
  children: contents_arr_rel_insert_input
  createdAt: timestamptz
  creator: users_obj_rel_insert_input
  creatorId: uuid
  data: String
  file: files_obj_rel_insert_input
  fileId: uuid
  folder: folders_obj_rel_insert_input
  folderId: uuid
  id: uuid
  name: String
  parent: contents_obj_rel_insert_input
  parentId: uuid
  polls: polls_arr_rel_insert_input
  priority: Int
  published: Boolean
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type contents_max_fields {
  createdAt: timestamptz
  creatorId: uuid
  data: String
  fileId: uuid
  folderId: uuid
  id: uuid
  name: String
  parentId: uuid
  priority: Int
  updatedAt: timestamptz
}

"""
order by max() on columns of table "contents"
"""
input contents_max_order_by {
  createdAt: order_by
  creatorId: order_by
  data: order_by
  fileId: order_by
  folderId: order_by
  id: order_by
  name: order_by
  parentId: order_by
  priority: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type contents_min_fields {
  createdAt: timestamptz
  creatorId: uuid
  data: String
  fileId: uuid
  folderId: uuid
  id: uuid
  name: String
  parentId: uuid
  priority: Int
  updatedAt: timestamptz
}

"""
order by min() on columns of table "contents"
"""
input contents_min_order_by {
  createdAt: order_by
  creatorId: order_by
  data: order_by
  fileId: order_by
  folderId: order_by
  id: order_by
  name: order_by
  parentId: order_by
  priority: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "contents"
"""
type contents_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [contents!]!
}

"""
input type for inserting object relation for remote table "contents"
"""
input contents_obj_rel_insert_input {
  data: contents_insert_input!
  on_conflict: contents_on_conflict
}

"""
on conflict condition type for table "contents"
"""
input contents_on_conflict {
  constraint: contents_constraint!
  update_columns: [contents_update_column!]!
  where: contents_bool_exp
}

"""
ordering options when selecting data from "contents"
"""
input contents_order_by {
  authors_aggregate: authorships_aggregate_order_by
  children_aggregate: contents_aggregate_order_by
  createdAt: order_by
  creator: users_order_by
  creatorId: order_by
  data: order_by
  file: files_order_by
  fileId: order_by
  folder: folders_order_by
  folderId: order_by
  id: order_by
  name: order_by
  parent: contents_order_by
  parentId: order_by
  polls_aggregate: polls_aggregate_order_by
  priority: order_by
  published: order_by
  updatedAt: order_by
}

"""
primary key columns input for table: "contents"
"""
input contents_pk_columns_input {
  id: uuid!
}

"""
select columns of table "contents"
"""
enum contents_select_column {
  """column name"""
  createdAt

  """column name"""
  creatorId

  """column name"""
  data

  """column name"""
  fileId

  """column name"""
  folderId

  """column name"""
  id

  """column name"""
  name

  """column name"""
  parentId

  """column name"""
  priority

  """column name"""
  published

  """column name"""
  updatedAt
}

"""
input type for updating data in table "contents"
"""
input contents_set_input {
  createdAt: timestamptz
  creatorId: uuid
  data: String
  fileId: uuid
  folderId: uuid
  id: uuid
  name: String
  parentId: uuid
  priority: Int
  published: Boolean
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type contents_stddev_fields {
  priority: Float
}

"""
order by stddev() on columns of table "contents"
"""
input contents_stddev_order_by {
  priority: order_by
}

"""aggregate stddev_pop on columns"""
type contents_stddev_pop_fields {
  priority: Float
}

"""
order by stddev_pop() on columns of table "contents"
"""
input contents_stddev_pop_order_by {
  priority: order_by
}

"""aggregate stddev_samp on columns"""
type contents_stddev_samp_fields {
  priority: Float
}

"""
order by stddev_samp() on columns of table "contents"
"""
input contents_stddev_samp_order_by {
  priority: order_by
}

"""aggregate sum on columns"""
type contents_sum_fields {
  priority: Int
}

"""
order by sum() on columns of table "contents"
"""
input contents_sum_order_by {
  priority: order_by
}

"""
update columns of table "contents"
"""
enum contents_update_column {
  """column name"""
  createdAt

  """column name"""
  creatorId

  """column name"""
  data

  """column name"""
  fileId

  """column name"""
  folderId

  """column name"""
  id

  """column name"""
  name

  """column name"""
  parentId

  """column name"""
  priority

  """column name"""
  published

  """column name"""
  updatedAt
}

"""aggregate var_pop on columns"""
type contents_var_pop_fields {
  priority: Float
}

"""
order by var_pop() on columns of table "contents"
"""
input contents_var_pop_order_by {
  priority: order_by
}

"""aggregate var_samp on columns"""
type contents_var_samp_fields {
  priority: Float
}

"""
order by var_samp() on columns of table "contents"
"""
input contents_var_samp_order_by {
  priority: order_by
}

"""aggregate variance on columns"""
type contents_variance_fields {
  priority: Float
}

"""
order by variance() on columns of table "contents"
"""
input contents_variance_order_by {
  priority: order_by
}

"""
columns and relationships of "events"
"""
type events {
  """An array relationship"""
  admissions(
    """distinct select on columns"""
    distinct_on: [admissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admissions_order_by!]

    """filter the rows returned"""
    where: admissions_bool_exp
  ): [admissions!]!

  """An aggregated array relationship"""
  admissions_aggregate(
    """distinct select on columns"""
    distinct_on: [admissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admissions_order_by!]

    """filter the rows returned"""
    where: admissions_bool_exp
  ): admissions_aggregate!

  """An object relationship"""
  content: contents
  contentId: uuid
  createdAt: timestamptz!

  """An object relationship"""
  folder: folders
  folderId: uuid

  """An object relationship"""
  group: groups
  groupId: uuid!
  id: uuid!
  name: String!

  """An object relationship"""
  poll: polls
  pollId: uuid
  shortName: String!

  """An object relationship"""
  speakerlist: speakerlists
  speakerlistId: uuid

  """An array relationship"""
  speakerlists(
    """distinct select on columns"""
    distinct_on: [speakerlists_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [speakerlists_order_by!]

    """filter the rows returned"""
    where: speakerlists_bool_exp
  ): [speakerlists!]!

  """An aggregated array relationship"""
  speakerlists_aggregate(
    """distinct select on columns"""
    distinct_on: [speakerlists_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [speakerlists_order_by!]

    """filter the rows returned"""
    where: speakerlists_bool_exp
  ): speakerlists_aggregate!
}

"""
aggregated selection of "events"
"""
type events_aggregate {
  aggregate: events_aggregate_fields
  nodes: [events!]!
}

"""
aggregate fields of "events"
"""
type events_aggregate_fields {
  count(columns: [events_select_column!], distinct: Boolean): Int
  max: events_max_fields
  min: events_min_fields
}

"""
order by aggregate values of table "events"
"""
input events_aggregate_order_by {
  count: order_by
  max: events_max_order_by
  min: events_min_order_by
}

"""
input type for inserting array relation for remote table "events"
"""
input events_arr_rel_insert_input {
  data: [events_insert_input!]!
  on_conflict: events_on_conflict
}

"""
Boolean expression to filter rows from the table "events". All fields are combined with a logical 'AND'.
"""
input events_bool_exp {
  _and: [events_bool_exp]
  _not: events_bool_exp
  _or: [events_bool_exp]
  admissions: admissions_bool_exp
  content: contents_bool_exp
  contentId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  folder: folders_bool_exp
  folderId: uuid_comparison_exp
  group: groups_bool_exp
  groupId: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  poll: polls_bool_exp
  pollId: uuid_comparison_exp
  shortName: String_comparison_exp
  speakerlist: speakerlists_bool_exp
  speakerlistId: uuid_comparison_exp
  speakerlists: speakerlists_bool_exp
}

"""
unique or primary key constraints on table "events"
"""
enum events_constraint {
  """unique or primary key constraint"""
  events_pkey
}

"""
input type for inserting data into table "events"
"""
input events_insert_input {
  admissions: admissions_arr_rel_insert_input
  content: contents_obj_rel_insert_input
  contentId: uuid
  createdAt: timestamptz
  folder: folders_obj_rel_insert_input
  folderId: uuid
  group: groups_obj_rel_insert_input
  groupId: uuid
  id: uuid
  name: String
  poll: polls_obj_rel_insert_input
  pollId: uuid
  shortName: String
  speakerlist: speakerlists_obj_rel_insert_input
  speakerlistId: uuid
  speakerlists: speakerlists_arr_rel_insert_input
}

"""aggregate max on columns"""
type events_max_fields {
  contentId: uuid
  createdAt: timestamptz
  folderId: uuid
  groupId: uuid
  id: uuid
  name: String
  pollId: uuid
  shortName: String
  speakerlistId: uuid
}

"""
order by max() on columns of table "events"
"""
input events_max_order_by {
  contentId: order_by
  createdAt: order_by
  folderId: order_by
  groupId: order_by
  id: order_by
  name: order_by
  pollId: order_by
  shortName: order_by
  speakerlistId: order_by
}

"""aggregate min on columns"""
type events_min_fields {
  contentId: uuid
  createdAt: timestamptz
  folderId: uuid
  groupId: uuid
  id: uuid
  name: String
  pollId: uuid
  shortName: String
  speakerlistId: uuid
}

"""
order by min() on columns of table "events"
"""
input events_min_order_by {
  contentId: order_by
  createdAt: order_by
  folderId: order_by
  groupId: order_by
  id: order_by
  name: order_by
  pollId: order_by
  shortName: order_by
  speakerlistId: order_by
}

"""
response of any mutation on the table "events"
"""
type events_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [events!]!
}

"""
input type for inserting object relation for remote table "events"
"""
input events_obj_rel_insert_input {
  data: events_insert_input!
  on_conflict: events_on_conflict
}

"""
on conflict condition type for table "events"
"""
input events_on_conflict {
  constraint: events_constraint!
  update_columns: [events_update_column!]!
  where: events_bool_exp
}

"""
ordering options when selecting data from "events"
"""
input events_order_by {
  admissions_aggregate: admissions_aggregate_order_by
  content: contents_order_by
  contentId: order_by
  createdAt: order_by
  folder: folders_order_by
  folderId: order_by
  group: groups_order_by
  groupId: order_by
  id: order_by
  name: order_by
  poll: polls_order_by
  pollId: order_by
  shortName: order_by
  speakerlist: speakerlists_order_by
  speakerlistId: order_by
  speakerlists_aggregate: speakerlists_aggregate_order_by
}

"""
primary key columns input for table: "events"
"""
input events_pk_columns_input {
  id: uuid!
}

"""
select columns of table "events"
"""
enum events_select_column {
  """column name"""
  contentId

  """column name"""
  createdAt

  """column name"""
  folderId

  """column name"""
  groupId

  """column name"""
  id

  """column name"""
  name

  """column name"""
  pollId

  """column name"""
  shortName

  """column name"""
  speakerlistId
}

"""
input type for updating data in table "events"
"""
input events_set_input {
  contentId: uuid
  createdAt: timestamptz
  folderId: uuid
  groupId: uuid
  id: uuid
  name: String
  pollId: uuid
  shortName: String
  speakerlistId: uuid
}

"""
update columns of table "events"
"""
enum events_update_column {
  """column name"""
  contentId

  """column name"""
  createdAt

  """column name"""
  folderId

  """column name"""
  groupId

  """column name"""
  id

  """column name"""
  name

  """column name"""
  pollId

  """column name"""
  shortName

  """column name"""
  speakerlistId
}

"""
columns and relationships of "files"
"""
type files {
  createdAt: timestamptz!
  id: uuid!
  path: String!
  token: String!
  updatedAt: timestamptz!

  """An object relationship"""
  user: users
  userId: uuid!
}

"""
aggregated selection of "files"
"""
type files_aggregate {
  aggregate: files_aggregate_fields
  nodes: [files!]!
}

"""
aggregate fields of "files"
"""
type files_aggregate_fields {
  count(columns: [files_select_column!], distinct: Boolean): Int
  max: files_max_fields
  min: files_min_fields
}

"""
order by aggregate values of table "files"
"""
input files_aggregate_order_by {
  count: order_by
  max: files_max_order_by
  min: files_min_order_by
}

"""
input type for inserting array relation for remote table "files"
"""
input files_arr_rel_insert_input {
  data: [files_insert_input!]!
  on_conflict: files_on_conflict
}

"""
Boolean expression to filter rows from the table "files". All fields are combined with a logical 'AND'.
"""
input files_bool_exp {
  _and: [files_bool_exp]
  _not: files_bool_exp
  _or: [files_bool_exp]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  path: String_comparison_exp
  token: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "files"
"""
enum files_constraint {
  """unique or primary key constraint"""
  files_pkey
}

"""
input type for inserting data into table "files"
"""
input files_insert_input {
  createdAt: timestamptz
  id: uuid
  path: String
  token: String
  updatedAt: timestamptz
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type files_max_fields {
  createdAt: timestamptz
  id: uuid
  path: String
  token: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "files"
"""
input files_max_order_by {
  createdAt: order_by
  id: order_by
  path: order_by
  token: order_by
  updatedAt: order_by
  userId: order_by
}

"""aggregate min on columns"""
type files_min_fields {
  createdAt: timestamptz
  id: uuid
  path: String
  token: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "files"
"""
input files_min_order_by {
  createdAt: order_by
  id: order_by
  path: order_by
  token: order_by
  updatedAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "files"
"""
type files_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [files!]!
}

"""
input type for inserting object relation for remote table "files"
"""
input files_obj_rel_insert_input {
  data: files_insert_input!
  on_conflict: files_on_conflict
}

"""
on conflict condition type for table "files"
"""
input files_on_conflict {
  constraint: files_constraint!
  update_columns: [files_update_column!]!
  where: files_bool_exp
}

"""
ordering options when selecting data from "files"
"""
input files_order_by {
  createdAt: order_by
  id: order_by
  path: order_by
  token: order_by
  updatedAt: order_by
  user: users_order_by
  userId: order_by
}

"""
primary key columns input for table: "files"
"""
input files_pk_columns_input {
  id: uuid!
}

"""
select columns of table "files"
"""
enum files_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  path

  """column name"""
  token

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "files"
"""
input files_set_input {
  createdAt: timestamptz
  id: uuid
  path: String
  token: String
  updatedAt: timestamptz
  userId: uuid
}

"""
update columns of table "files"
"""
enum files_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  path

  """column name"""
  token

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
columns and relationships of "folders"
"""
type folders {
  """An array relationship"""
  contents(
    """distinct select on columns"""
    distinct_on: [contents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contents_order_by!]

    """filter the rows returned"""
    where: contents_bool_exp
  ): [contents!]!

  """An aggregated array relationship"""
  contents_aggregate(
    """distinct select on columns"""
    distinct_on: [contents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contents_order_by!]

    """filter the rows returned"""
    where: contents_bool_exp
  ): contents_aggregate!

  """An object relationship"""
  event: events
  eventId: uuid!

  """An array relationship"""
  folders(
    """distinct select on columns"""
    distinct_on: [folders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folders_order_by!]

    """filter the rows returned"""
    where: folders_bool_exp
  ): [folders!]!

  """An aggregated array relationship"""
  folders_aggregate(
    """distinct select on columns"""
    distinct_on: [folders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folders_order_by!]

    """filter the rows returned"""
    where: folders_bool_exp
  ): folders_aggregate!
  id: uuid!
  lockChildren: Boolean!
  lockContent: Boolean!
  mode: String!
  name: String!

  """An object relationship"""
  parent: folders
  parentId: uuid
  priority: Int!
  subtitle: String
}

"""
aggregated selection of "folders"
"""
type folders_aggregate {
  aggregate: folders_aggregate_fields
  nodes: [folders!]!
}

"""
aggregate fields of "folders"
"""
type folders_aggregate_fields {
  avg: folders_avg_fields
  count(columns: [folders_select_column!], distinct: Boolean): Int
  max: folders_max_fields
  min: folders_min_fields
  stddev: folders_stddev_fields
  stddev_pop: folders_stddev_pop_fields
  stddev_samp: folders_stddev_samp_fields
  sum: folders_sum_fields
  var_pop: folders_var_pop_fields
  var_samp: folders_var_samp_fields
  variance: folders_variance_fields
}

"""
order by aggregate values of table "folders"
"""
input folders_aggregate_order_by {
  avg: folders_avg_order_by
  count: order_by
  max: folders_max_order_by
  min: folders_min_order_by
  stddev: folders_stddev_order_by
  stddev_pop: folders_stddev_pop_order_by
  stddev_samp: folders_stddev_samp_order_by
  sum: folders_sum_order_by
  var_pop: folders_var_pop_order_by
  var_samp: folders_var_samp_order_by
  variance: folders_variance_order_by
}

"""
input type for inserting array relation for remote table "folders"
"""
input folders_arr_rel_insert_input {
  data: [folders_insert_input!]!
  on_conflict: folders_on_conflict
}

"""aggregate avg on columns"""
type folders_avg_fields {
  priority: Float
}

"""
order by avg() on columns of table "folders"
"""
input folders_avg_order_by {
  priority: order_by
}

"""
Boolean expression to filter rows from the table "folders". All fields are combined with a logical 'AND'.
"""
input folders_bool_exp {
  _and: [folders_bool_exp]
  _not: folders_bool_exp
  _or: [folders_bool_exp]
  contents: contents_bool_exp
  event: events_bool_exp
  eventId: uuid_comparison_exp
  folders: folders_bool_exp
  id: uuid_comparison_exp
  lockChildren: Boolean_comparison_exp
  lockContent: Boolean_comparison_exp
  mode: String_comparison_exp
  name: String_comparison_exp
  parent: folders_bool_exp
  parentId: uuid_comparison_exp
  priority: Int_comparison_exp
  subtitle: String_comparison_exp
}

"""
unique or primary key constraints on table "folders"
"""
enum folders_constraint {
  """unique or primary key constraint"""
  categories_pkey
}

"""
input type for incrementing integer column in table "folders"
"""
input folders_inc_input {
  priority: Int
}

"""
input type for inserting data into table "folders"
"""
input folders_insert_input {
  contents: contents_arr_rel_insert_input
  event: events_obj_rel_insert_input
  eventId: uuid
  folders: folders_arr_rel_insert_input
  id: uuid
  lockChildren: Boolean
  lockContent: Boolean
  mode: String
  name: String
  parent: folders_obj_rel_insert_input
  parentId: uuid
  priority: Int
  subtitle: String
}

"""aggregate max on columns"""
type folders_max_fields {
  eventId: uuid
  id: uuid
  mode: String
  name: String
  parentId: uuid
  priority: Int
  subtitle: String
}

"""
order by max() on columns of table "folders"
"""
input folders_max_order_by {
  eventId: order_by
  id: order_by
  mode: order_by
  name: order_by
  parentId: order_by
  priority: order_by
  subtitle: order_by
}

"""aggregate min on columns"""
type folders_min_fields {
  eventId: uuid
  id: uuid
  mode: String
  name: String
  parentId: uuid
  priority: Int
  subtitle: String
}

"""
order by min() on columns of table "folders"
"""
input folders_min_order_by {
  eventId: order_by
  id: order_by
  mode: order_by
  name: order_by
  parentId: order_by
  priority: order_by
  subtitle: order_by
}

"""
response of any mutation on the table "folders"
"""
type folders_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [folders!]!
}

"""
input type for inserting object relation for remote table "folders"
"""
input folders_obj_rel_insert_input {
  data: folders_insert_input!
  on_conflict: folders_on_conflict
}

"""
on conflict condition type for table "folders"
"""
input folders_on_conflict {
  constraint: folders_constraint!
  update_columns: [folders_update_column!]!
  where: folders_bool_exp
}

"""
ordering options when selecting data from "folders"
"""
input folders_order_by {
  contents_aggregate: contents_aggregate_order_by
  event: events_order_by
  eventId: order_by
  folders_aggregate: folders_aggregate_order_by
  id: order_by
  lockChildren: order_by
  lockContent: order_by
  mode: order_by
  name: order_by
  parent: folders_order_by
  parentId: order_by
  priority: order_by
  subtitle: order_by
}

"""
primary key columns input for table: "folders"
"""
input folders_pk_columns_input {
  id: uuid!
}

"""
select columns of table "folders"
"""
enum folders_select_column {
  """column name"""
  eventId

  """column name"""
  id

  """column name"""
  lockChildren

  """column name"""
  lockContent

  """column name"""
  mode

  """column name"""
  name

  """column name"""
  parentId

  """column name"""
  priority

  """column name"""
  subtitle
}

"""
input type for updating data in table "folders"
"""
input folders_set_input {
  eventId: uuid
  id: uuid
  lockChildren: Boolean
  lockContent: Boolean
  mode: String
  name: String
  parentId: uuid
  priority: Int
  subtitle: String
}

"""aggregate stddev on columns"""
type folders_stddev_fields {
  priority: Float
}

"""
order by stddev() on columns of table "folders"
"""
input folders_stddev_order_by {
  priority: order_by
}

"""aggregate stddev_pop on columns"""
type folders_stddev_pop_fields {
  priority: Float
}

"""
order by stddev_pop() on columns of table "folders"
"""
input folders_stddev_pop_order_by {
  priority: order_by
}

"""aggregate stddev_samp on columns"""
type folders_stddev_samp_fields {
  priority: Float
}

"""
order by stddev_samp() on columns of table "folders"
"""
input folders_stddev_samp_order_by {
  priority: order_by
}

"""aggregate sum on columns"""
type folders_sum_fields {
  priority: Int
}

"""
order by sum() on columns of table "folders"
"""
input folders_sum_order_by {
  priority: order_by
}

"""
update columns of table "folders"
"""
enum folders_update_column {
  """column name"""
  eventId

  """column name"""
  id

  """column name"""
  lockChildren

  """column name"""
  lockContent

  """column name"""
  mode

  """column name"""
  name

  """column name"""
  parentId

  """column name"""
  priority

  """column name"""
  subtitle
}

"""aggregate var_pop on columns"""
type folders_var_pop_fields {
  priority: Float
}

"""
order by var_pop() on columns of table "folders"
"""
input folders_var_pop_order_by {
  priority: order_by
}

"""aggregate var_samp on columns"""
type folders_var_samp_fields {
  priority: Float
}

"""
order by var_samp() on columns of table "folders"
"""
input folders_var_samp_order_by {
  priority: order_by
}

"""aggregate variance on columns"""
type folders_variance_fields {
  priority: Float
}

"""
order by variance() on columns of table "folders"
"""
input folders_variance_order_by {
  priority: order_by
}

"""
columns and relationships of "groups"
"""
type groups {
  createdAt: timestamptz!

  """An object relationship"""
  creator: users
  creatorId: uuid

  """An array relationship"""
  events(
    """distinct select on columns"""
    distinct_on: [events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [events_order_by!]

    """filter the rows returned"""
    where: events_bool_exp
  ): [events!]!

  """An aggregated array relationship"""
  events_aggregate(
    """distinct select on columns"""
    distinct_on: [events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [events_order_by!]

    """filter the rows returned"""
    where: events_bool_exp
  ): events_aggregate!
  id: uuid!

  """An array relationship"""
  memberships(
    """distinct select on columns"""
    distinct_on: [memberships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [memberships_order_by!]

    """filter the rows returned"""
    where: memberships_bool_exp
  ): [memberships!]!

  """An aggregated array relationship"""
  memberships_aggregate(
    """distinct select on columns"""
    distinct_on: [memberships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [memberships_order_by!]

    """filter the rows returned"""
    where: memberships_bool_exp
  ): memberships_aggregate!
  name: String!
  public: Boolean!
  shortName: String
}

"""
aggregated selection of "groups"
"""
type groups_aggregate {
  aggregate: groups_aggregate_fields
  nodes: [groups!]!
}

"""
aggregate fields of "groups"
"""
type groups_aggregate_fields {
  count(columns: [groups_select_column!], distinct: Boolean): Int
  max: groups_max_fields
  min: groups_min_fields
}

"""
order by aggregate values of table "groups"
"""
input groups_aggregate_order_by {
  count: order_by
  max: groups_max_order_by
  min: groups_min_order_by
}

"""
input type for inserting array relation for remote table "groups"
"""
input groups_arr_rel_insert_input {
  data: [groups_insert_input!]!
  on_conflict: groups_on_conflict
}

"""
Boolean expression to filter rows from the table "groups". All fields are combined with a logical 'AND'.
"""
input groups_bool_exp {
  _and: [groups_bool_exp]
  _not: groups_bool_exp
  _or: [groups_bool_exp]
  createdAt: timestamptz_comparison_exp
  creator: users_bool_exp
  creatorId: uuid_comparison_exp
  events: events_bool_exp
  id: uuid_comparison_exp
  memberships: memberships_bool_exp
  name: String_comparison_exp
  public: Boolean_comparison_exp
  shortName: String_comparison_exp
}

"""
unique or primary key constraints on table "groups"
"""
enum groups_constraint {
  """unique or primary key constraint"""
  groups_pkey
}

"""
input type for inserting data into table "groups"
"""
input groups_insert_input {
  createdAt: timestamptz
  creator: users_obj_rel_insert_input
  creatorId: uuid
  events: events_arr_rel_insert_input
  id: uuid
  memberships: memberships_arr_rel_insert_input
  name: String
  public: Boolean
  shortName: String
}

"""aggregate max on columns"""
type groups_max_fields {
  createdAt: timestamptz
  creatorId: uuid
  id: uuid
  name: String
  shortName: String
}

"""
order by max() on columns of table "groups"
"""
input groups_max_order_by {
  createdAt: order_by
  creatorId: order_by
  id: order_by
  name: order_by
  shortName: order_by
}

"""aggregate min on columns"""
type groups_min_fields {
  createdAt: timestamptz
  creatorId: uuid
  id: uuid
  name: String
  shortName: String
}

"""
order by min() on columns of table "groups"
"""
input groups_min_order_by {
  createdAt: order_by
  creatorId: order_by
  id: order_by
  name: order_by
  shortName: order_by
}

"""
response of any mutation on the table "groups"
"""
type groups_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [groups!]!
}

"""
input type for inserting object relation for remote table "groups"
"""
input groups_obj_rel_insert_input {
  data: groups_insert_input!
  on_conflict: groups_on_conflict
}

"""
on conflict condition type for table "groups"
"""
input groups_on_conflict {
  constraint: groups_constraint!
  update_columns: [groups_update_column!]!
  where: groups_bool_exp
}

"""
ordering options when selecting data from "groups"
"""
input groups_order_by {
  createdAt: order_by
  creator: users_order_by
  creatorId: order_by
  events_aggregate: events_aggregate_order_by
  id: order_by
  memberships_aggregate: memberships_aggregate_order_by
  name: order_by
  public: order_by
  shortName: order_by
}

"""
primary key columns input for table: "groups"
"""
input groups_pk_columns_input {
  id: uuid!
}

"""
select columns of table "groups"
"""
enum groups_select_column {
  """column name"""
  createdAt

  """column name"""
  creatorId

  """column name"""
  id

  """column name"""
  name

  """column name"""
  public

  """column name"""
  shortName
}

"""
input type for updating data in table "groups"
"""
input groups_set_input {
  createdAt: timestamptz
  creatorId: uuid
  id: uuid
  name: String
  public: Boolean
  shortName: String
}

"""
update columns of table "groups"
"""
enum groups_update_column {
  """column name"""
  createdAt

  """column name"""
  creatorId

  """column name"""
  id

  """column name"""
  name

  """column name"""
  public

  """column name"""
  shortName
}

"""
columns and relationships of "identities"
"""
type identities {
  displayName: String!
  email: String!

  """An array relationship"""
  memberships(
    """distinct select on columns"""
    distinct_on: [memberships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [memberships_order_by!]

    """filter the rows returned"""
    where: memberships_bool_exp
  ): [memberships!]!

  """An aggregated array relationship"""
  memberships_aggregate(
    """distinct select on columns"""
    distinct_on: [memberships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [memberships_order_by!]

    """filter the rows returned"""
    where: memberships_bool_exp
  ): memberships_aggregate!

  """An object relationship"""
  user: users
}

"""
aggregated selection of "identities"
"""
type identities_aggregate {
  aggregate: identities_aggregate_fields
  nodes: [identities!]!
}

"""
aggregate fields of "identities"
"""
type identities_aggregate_fields {
  count(columns: [identities_select_column!], distinct: Boolean): Int
  max: identities_max_fields
  min: identities_min_fields
}

"""
order by aggregate values of table "identities"
"""
input identities_aggregate_order_by {
  count: order_by
  max: identities_max_order_by
  min: identities_min_order_by
}

"""
input type for inserting array relation for remote table "identities"
"""
input identities_arr_rel_insert_input {
  data: [identities_insert_input!]!
  on_conflict: identities_on_conflict
}

"""
Boolean expression to filter rows from the table "identities". All fields are combined with a logical 'AND'.
"""
input identities_bool_exp {
  _and: [identities_bool_exp]
  _not: identities_bool_exp
  _or: [identities_bool_exp]
  displayName: String_comparison_exp
  email: String_comparison_exp
  memberships: memberships_bool_exp
  user: users_bool_exp
}

"""
unique or primary key constraints on table "identities"
"""
enum identities_constraint {
  """unique or primary key constraint"""
  idEmails_pkey
}

"""
input type for inserting data into table "identities"
"""
input identities_insert_input {
  displayName: String
  email: String
  memberships: memberships_arr_rel_insert_input
  user: users_obj_rel_insert_input
}

"""aggregate max on columns"""
type identities_max_fields {
  displayName: String
  email: String
}

"""
order by max() on columns of table "identities"
"""
input identities_max_order_by {
  displayName: order_by
  email: order_by
}

"""aggregate min on columns"""
type identities_min_fields {
  displayName: String
  email: String
}

"""
order by min() on columns of table "identities"
"""
input identities_min_order_by {
  displayName: order_by
  email: order_by
}

"""
response of any mutation on the table "identities"
"""
type identities_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [identities!]!
}

"""
input type for inserting object relation for remote table "identities"
"""
input identities_obj_rel_insert_input {
  data: identities_insert_input!
  on_conflict: identities_on_conflict
}

"""
on conflict condition type for table "identities"
"""
input identities_on_conflict {
  constraint: identities_constraint!
  update_columns: [identities_update_column!]!
  where: identities_bool_exp
}

"""
ordering options when selecting data from "identities"
"""
input identities_order_by {
  displayName: order_by
  email: order_by
  memberships_aggregate: memberships_aggregate_order_by
  user: users_order_by
}

"""
primary key columns input for table: "identities"
"""
input identities_pk_columns_input {
  email: String!
}

"""
select columns of table "identities"
"""
enum identities_select_column {
  """column name"""
  displayName

  """column name"""
  email
}

"""
input type for updating data in table "identities"
"""
input identities_set_input {
  displayName: String
  email: String
}

"""
update columns of table "identities"
"""
enum identities_update_column {
  """column name"""
  displayName

  """column name"""
  email
}

scalar json

"""
expression to compare columns of type json. All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

scalar jsonb

"""
expression to compare columns of type jsonb. All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "memberships"
"""
type memberships {
  email: String

  """An object relationship"""
  group: groups
  groupId: uuid!
  id: uuid!

  """An object relationship"""
  identity: identities

  """An array relationship"""
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """An aggregated array relationship"""
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!
  userId: uuid
}

"""
aggregated selection of "memberships"
"""
type memberships_aggregate {
  aggregate: memberships_aggregate_fields
  nodes: [memberships!]!
}

"""
aggregate fields of "memberships"
"""
type memberships_aggregate_fields {
  count(columns: [memberships_select_column!], distinct: Boolean): Int
  max: memberships_max_fields
  min: memberships_min_fields
}

"""
order by aggregate values of table "memberships"
"""
input memberships_aggregate_order_by {
  count: order_by
  max: memberships_max_order_by
  min: memberships_min_order_by
}

"""
input type for inserting array relation for remote table "memberships"
"""
input memberships_arr_rel_insert_input {
  data: [memberships_insert_input!]!
  on_conflict: memberships_on_conflict
}

"""
Boolean expression to filter rows from the table "memberships". All fields are combined with a logical 'AND'.
"""
input memberships_bool_exp {
  _and: [memberships_bool_exp]
  _not: memberships_bool_exp
  _or: [memberships_bool_exp]
  email: String_comparison_exp
  group: groups_bool_exp
  groupId: uuid_comparison_exp
  id: uuid_comparison_exp
  identity: identities_bool_exp
  roles: roles_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "memberships"
"""
enum memberships_constraint {
  """unique or primary key constraint"""
  memberships_pkey
}

"""
input type for inserting data into table "memberships"
"""
input memberships_insert_input {
  email: String
  group: groups_obj_rel_insert_input
  groupId: uuid
  id: uuid
  identity: identities_obj_rel_insert_input
  roles: roles_arr_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type memberships_max_fields {
  email: String
  groupId: uuid
  id: uuid
  userId: uuid
}

"""
order by max() on columns of table "memberships"
"""
input memberships_max_order_by {
  email: order_by
  groupId: order_by
  id: order_by
  userId: order_by
}

"""aggregate min on columns"""
type memberships_min_fields {
  email: String
  groupId: uuid
  id: uuid
  userId: uuid
}

"""
order by min() on columns of table "memberships"
"""
input memberships_min_order_by {
  email: order_by
  groupId: order_by
  id: order_by
  userId: order_by
}

"""
response of any mutation on the table "memberships"
"""
type memberships_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [memberships!]!
}

"""
input type for inserting object relation for remote table "memberships"
"""
input memberships_obj_rel_insert_input {
  data: memberships_insert_input!
  on_conflict: memberships_on_conflict
}

"""
on conflict condition type for table "memberships"
"""
input memberships_on_conflict {
  constraint: memberships_constraint!
  update_columns: [memberships_update_column!]!
  where: memberships_bool_exp
}

"""
ordering options when selecting data from "memberships"
"""
input memberships_order_by {
  email: order_by
  group: groups_order_by
  groupId: order_by
  id: order_by
  identity: identities_order_by
  roles_aggregate: roles_aggregate_order_by
  userId: order_by
}

"""
primary key columns input for table: "memberships"
"""
input memberships_pk_columns_input {
  id: uuid!
}

"""
select columns of table "memberships"
"""
enum memberships_select_column {
  """column name"""
  email

  """column name"""
  groupId

  """column name"""
  id

  """column name"""
  userId
}

"""
input type for updating data in table "memberships"
"""
input memberships_set_input {
  email: String
  groupId: uuid
  id: uuid
  userId: uuid
}

"""
update columns of table "memberships"
"""
enum memberships_update_column {
  """column name"""
  email

  """column name"""
  groupId

  """column name"""
  id

  """column name"""
  userId
}

"""mutation root"""
type mutation_root {
  """
  perform the action: "addVote"
  """
  addVote(vote: VoteInput!): VoteOutput!

  """
  delete data from the table: "admissions"
  """
  delete_admissions(
    """filter the rows which have to be deleted"""
    where: admissions_bool_exp!
  ): admissions_mutation_response

  """
  delete single row from the table: "admissions"
  """
  delete_admissions_by_pk(id: uuid!): admissions

  """
  delete data from the table: "auth.account_providers"
  """
  delete_auth_account_providers(
    """filter the rows which have to be deleted"""
    where: auth_account_providers_bool_exp!
  ): auth_account_providers_mutation_response

  """
  delete single row from the table: "auth.account_providers"
  """
  delete_auth_account_providers_by_pk(id: uuid!): auth_account_providers

  """
  delete data from the table: "auth.account_roles"
  """
  delete_auth_account_roles(
    """filter the rows which have to be deleted"""
    where: auth_account_roles_bool_exp!
  ): auth_account_roles_mutation_response

  """
  delete single row from the table: "auth.account_roles"
  """
  delete_auth_account_roles_by_pk(id: uuid!): auth_account_roles

  """
  delete data from the table: "auth.accounts"
  """
  delete_auth_accounts(
    """filter the rows which have to be deleted"""
    where: auth_accounts_bool_exp!
  ): auth_accounts_mutation_response

  """
  delete single row from the table: "auth.accounts"
  """
  delete_auth_accounts_by_pk(id: uuid!): auth_accounts

  """
  delete data from the table: "auth.providers"
  """
  delete_auth_providers(
    """filter the rows which have to be deleted"""
    where: auth_providers_bool_exp!
  ): auth_providers_mutation_response

  """
  delete single row from the table: "auth.providers"
  """
  delete_auth_providers_by_pk(provider: String!): auth_providers

  """
  delete data from the table: "auth.refresh_tokens"
  """
  delete_auth_refresh_tokens(
    """filter the rows which have to be deleted"""
    where: auth_refresh_tokens_bool_exp!
  ): auth_refresh_tokens_mutation_response

  """
  delete single row from the table: "auth.refresh_tokens"
  """
  delete_auth_refresh_tokens_by_pk(refresh_token: uuid!): auth_refresh_tokens

  """
  delete data from the table: "auth.roles"
  """
  delete_auth_roles(
    """filter the rows which have to be deleted"""
    where: auth_roles_bool_exp!
  ): auth_roles_mutation_response

  """
  delete single row from the table: "auth.roles"
  """
  delete_auth_roles_by_pk(role: String!): auth_roles

  """
  delete data from the table: "authorships"
  """
  delete_authorships(
    """filter the rows which have to be deleted"""
    where: authorships_bool_exp!
  ): authorships_mutation_response

  """
  delete single row from the table: "authorships"
  """
  delete_authorships_by_pk(id: uuid!): authorships

  """
  delete data from the table: "contents"
  """
  delete_contents(
    """filter the rows which have to be deleted"""
    where: contents_bool_exp!
  ): contents_mutation_response

  """
  delete single row from the table: "contents"
  """
  delete_contents_by_pk(id: uuid!): contents

  """
  delete data from the table: "events"
  """
  delete_events(
    """filter the rows which have to be deleted"""
    where: events_bool_exp!
  ): events_mutation_response

  """
  delete single row from the table: "events"
  """
  delete_events_by_pk(id: uuid!): events

  """
  delete data from the table: "files"
  """
  delete_files(
    """filter the rows which have to be deleted"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  delete single row from the table: "files"
  """
  delete_files_by_pk(id: uuid!): files

  """
  delete data from the table: "folders"
  """
  delete_folders(
    """filter the rows which have to be deleted"""
    where: folders_bool_exp!
  ): folders_mutation_response

  """
  delete single row from the table: "folders"
  """
  delete_folders_by_pk(id: uuid!): folders

  """
  delete data from the table: "groups"
  """
  delete_groups(
    """filter the rows which have to be deleted"""
    where: groups_bool_exp!
  ): groups_mutation_response

  """
  delete single row from the table: "groups"
  """
  delete_groups_by_pk(id: uuid!): groups

  """
  delete data from the table: "identities"
  """
  delete_identities(
    """filter the rows which have to be deleted"""
    where: identities_bool_exp!
  ): identities_mutation_response

  """
  delete single row from the table: "identities"
  """
  delete_identities_by_pk(email: String!): identities

  """
  delete data from the table: "memberships"
  """
  delete_memberships(
    """filter the rows which have to be deleted"""
    where: memberships_bool_exp!
  ): memberships_mutation_response

  """
  delete single row from the table: "memberships"
  """
  delete_memberships_by_pk(id: uuid!): memberships

  """
  delete data from the table: "polls"
  """
  delete_polls(
    """filter the rows which have to be deleted"""
    where: polls_bool_exp!
  ): polls_mutation_response

  """
  delete single row from the table: "polls"
  """
  delete_polls_by_pk(id: uuid!): polls

  """
  delete data from the table: "roles"
  """
  delete_roles(
    """filter the rows which have to be deleted"""
    where: roles_bool_exp!
  ): roles_mutation_response

  """
  delete single row from the table: "roles"
  """
  delete_roles_by_pk(id: uuid!): roles

  """
  delete data from the table: "speakerlists"
  """
  delete_speakerlists(
    """filter the rows which have to be deleted"""
    where: speakerlists_bool_exp!
  ): speakerlists_mutation_response

  """
  delete single row from the table: "speakerlists"
  """
  delete_speakerlists_by_pk(id: uuid!): speakerlists

  """
  delete data from the table: "speaks"
  """
  delete_speaks(
    """filter the rows which have to be deleted"""
    where: speaks_bool_exp!
  ): speaks_mutation_response

  """
  delete single row from the table: "speaks"
  """
  delete_speaks_by_pk(id: uuid!): speaks

  """
  delete data from the table: "timers"
  """
  delete_timers(
    """filter the rows which have to be deleted"""
    where: timers_bool_exp!
  ): timers_mutation_response

  """
  delete single row from the table: "timers"
  """
  delete_timers_by_pk(id: uuid!): timers

  """
  delete data from the table: "users"
  """
  delete_users(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(id: uuid!): users

  """
  delete data from the table: "votes"
  """
  delete_votes(
    """filter the rows which have to be deleted"""
    where: votes_bool_exp!
  ): votes_mutation_response

  """
  delete single row from the table: "votes"
  """
  delete_votes_by_pk(id: uuid!): votes

  """
  insert data into the table: "admissions"
  """
  insert_admissions(
    """the rows to be inserted"""
    objects: [admissions_insert_input!]!

    """on conflict condition"""
    on_conflict: admissions_on_conflict
  ): admissions_mutation_response

  """
  insert a single row into the table: "admissions"
  """
  insert_admissions_one(
    """the row to be inserted"""
    object: admissions_insert_input!

    """on conflict condition"""
    on_conflict: admissions_on_conflict
  ): admissions

  """
  insert data into the table: "auth.account_providers"
  """
  insert_auth_account_providers(
    """the rows to be inserted"""
    objects: [auth_account_providers_insert_input!]!

    """on conflict condition"""
    on_conflict: auth_account_providers_on_conflict
  ): auth_account_providers_mutation_response

  """
  insert a single row into the table: "auth.account_providers"
  """
  insert_auth_account_providers_one(
    """the row to be inserted"""
    object: auth_account_providers_insert_input!

    """on conflict condition"""
    on_conflict: auth_account_providers_on_conflict
  ): auth_account_providers

  """
  insert data into the table: "auth.account_roles"
  """
  insert_auth_account_roles(
    """the rows to be inserted"""
    objects: [auth_account_roles_insert_input!]!

    """on conflict condition"""
    on_conflict: auth_account_roles_on_conflict
  ): auth_account_roles_mutation_response

  """
  insert a single row into the table: "auth.account_roles"
  """
  insert_auth_account_roles_one(
    """the row to be inserted"""
    object: auth_account_roles_insert_input!

    """on conflict condition"""
    on_conflict: auth_account_roles_on_conflict
  ): auth_account_roles

  """
  insert data into the table: "auth.accounts"
  """
  insert_auth_accounts(
    """the rows to be inserted"""
    objects: [auth_accounts_insert_input!]!

    """on conflict condition"""
    on_conflict: auth_accounts_on_conflict
  ): auth_accounts_mutation_response

  """
  insert a single row into the table: "auth.accounts"
  """
  insert_auth_accounts_one(
    """the row to be inserted"""
    object: auth_accounts_insert_input!

    """on conflict condition"""
    on_conflict: auth_accounts_on_conflict
  ): auth_accounts

  """
  insert data into the table: "auth.providers"
  """
  insert_auth_providers(
    """the rows to be inserted"""
    objects: [auth_providers_insert_input!]!

    """on conflict condition"""
    on_conflict: auth_providers_on_conflict
  ): auth_providers_mutation_response

  """
  insert a single row into the table: "auth.providers"
  """
  insert_auth_providers_one(
    """the row to be inserted"""
    object: auth_providers_insert_input!

    """on conflict condition"""
    on_conflict: auth_providers_on_conflict
  ): auth_providers

  """
  insert data into the table: "auth.refresh_tokens"
  """
  insert_auth_refresh_tokens(
    """the rows to be inserted"""
    objects: [auth_refresh_tokens_insert_input!]!

    """on conflict condition"""
    on_conflict: auth_refresh_tokens_on_conflict
  ): auth_refresh_tokens_mutation_response

  """
  insert a single row into the table: "auth.refresh_tokens"
  """
  insert_auth_refresh_tokens_one(
    """the row to be inserted"""
    object: auth_refresh_tokens_insert_input!

    """on conflict condition"""
    on_conflict: auth_refresh_tokens_on_conflict
  ): auth_refresh_tokens

  """
  insert data into the table: "auth.roles"
  """
  insert_auth_roles(
    """the rows to be inserted"""
    objects: [auth_roles_insert_input!]!

    """on conflict condition"""
    on_conflict: auth_roles_on_conflict
  ): auth_roles_mutation_response

  """
  insert a single row into the table: "auth.roles"
  """
  insert_auth_roles_one(
    """the row to be inserted"""
    object: auth_roles_insert_input!

    """on conflict condition"""
    on_conflict: auth_roles_on_conflict
  ): auth_roles

  """
  insert data into the table: "authorships"
  """
  insert_authorships(
    """the rows to be inserted"""
    objects: [authorships_insert_input!]!

    """on conflict condition"""
    on_conflict: authorships_on_conflict
  ): authorships_mutation_response

  """
  insert a single row into the table: "authorships"
  """
  insert_authorships_one(
    """the row to be inserted"""
    object: authorships_insert_input!

    """on conflict condition"""
    on_conflict: authorships_on_conflict
  ): authorships

  """
  insert data into the table: "contents"
  """
  insert_contents(
    """the rows to be inserted"""
    objects: [contents_insert_input!]!

    """on conflict condition"""
    on_conflict: contents_on_conflict
  ): contents_mutation_response

  """
  insert a single row into the table: "contents"
  """
  insert_contents_one(
    """the row to be inserted"""
    object: contents_insert_input!

    """on conflict condition"""
    on_conflict: contents_on_conflict
  ): contents

  """
  insert data into the table: "events"
  """
  insert_events(
    """the rows to be inserted"""
    objects: [events_insert_input!]!

    """on conflict condition"""
    on_conflict: events_on_conflict
  ): events_mutation_response

  """
  insert a single row into the table: "events"
  """
  insert_events_one(
    """the row to be inserted"""
    object: events_insert_input!

    """on conflict condition"""
    on_conflict: events_on_conflict
  ): events

  """
  insert data into the table: "files"
  """
  insert_files(
    """the rows to be inserted"""
    objects: [files_insert_input!]!

    """on conflict condition"""
    on_conflict: files_on_conflict
  ): files_mutation_response

  """
  insert a single row into the table: "files"
  """
  insert_files_one(
    """the row to be inserted"""
    object: files_insert_input!

    """on conflict condition"""
    on_conflict: files_on_conflict
  ): files

  """
  insert data into the table: "folders"
  """
  insert_folders(
    """the rows to be inserted"""
    objects: [folders_insert_input!]!

    """on conflict condition"""
    on_conflict: folders_on_conflict
  ): folders_mutation_response

  """
  insert a single row into the table: "folders"
  """
  insert_folders_one(
    """the row to be inserted"""
    object: folders_insert_input!

    """on conflict condition"""
    on_conflict: folders_on_conflict
  ): folders

  """
  insert data into the table: "groups"
  """
  insert_groups(
    """the rows to be inserted"""
    objects: [groups_insert_input!]!

    """on conflict condition"""
    on_conflict: groups_on_conflict
  ): groups_mutation_response

  """
  insert a single row into the table: "groups"
  """
  insert_groups_one(
    """the row to be inserted"""
    object: groups_insert_input!

    """on conflict condition"""
    on_conflict: groups_on_conflict
  ): groups

  """
  insert data into the table: "identities"
  """
  insert_identities(
    """the rows to be inserted"""
    objects: [identities_insert_input!]!

    """on conflict condition"""
    on_conflict: identities_on_conflict
  ): identities_mutation_response

  """
  insert a single row into the table: "identities"
  """
  insert_identities_one(
    """the row to be inserted"""
    object: identities_insert_input!

    """on conflict condition"""
    on_conflict: identities_on_conflict
  ): identities

  """
  insert data into the table: "memberships"
  """
  insert_memberships(
    """the rows to be inserted"""
    objects: [memberships_insert_input!]!

    """on conflict condition"""
    on_conflict: memberships_on_conflict
  ): memberships_mutation_response

  """
  insert a single row into the table: "memberships"
  """
  insert_memberships_one(
    """the row to be inserted"""
    object: memberships_insert_input!

    """on conflict condition"""
    on_conflict: memberships_on_conflict
  ): memberships

  """
  insert data into the table: "polls"
  """
  insert_polls(
    """the rows to be inserted"""
    objects: [polls_insert_input!]!

    """on conflict condition"""
    on_conflict: polls_on_conflict
  ): polls_mutation_response

  """
  insert a single row into the table: "polls"
  """
  insert_polls_one(
    """the row to be inserted"""
    object: polls_insert_input!

    """on conflict condition"""
    on_conflict: polls_on_conflict
  ): polls

  """
  insert data into the table: "roles"
  """
  insert_roles(
    """the rows to be inserted"""
    objects: [roles_insert_input!]!

    """on conflict condition"""
    on_conflict: roles_on_conflict
  ): roles_mutation_response

  """
  insert a single row into the table: "roles"
  """
  insert_roles_one(
    """the row to be inserted"""
    object: roles_insert_input!

    """on conflict condition"""
    on_conflict: roles_on_conflict
  ): roles

  """
  insert data into the table: "speakerlists"
  """
  insert_speakerlists(
    """the rows to be inserted"""
    objects: [speakerlists_insert_input!]!

    """on conflict condition"""
    on_conflict: speakerlists_on_conflict
  ): speakerlists_mutation_response

  """
  insert a single row into the table: "speakerlists"
  """
  insert_speakerlists_one(
    """the row to be inserted"""
    object: speakerlists_insert_input!

    """on conflict condition"""
    on_conflict: speakerlists_on_conflict
  ): speakerlists

  """
  insert data into the table: "speaks"
  """
  insert_speaks(
    """the rows to be inserted"""
    objects: [speaks_insert_input!]!

    """on conflict condition"""
    on_conflict: speaks_on_conflict
  ): speaks_mutation_response

  """
  insert a single row into the table: "speaks"
  """
  insert_speaks_one(
    """the row to be inserted"""
    object: speaks_insert_input!

    """on conflict condition"""
    on_conflict: speaks_on_conflict
  ): speaks

  """
  insert data into the table: "timers"
  """
  insert_timers(
    """the rows to be inserted"""
    objects: [timers_insert_input!]!

    """on conflict condition"""
    on_conflict: timers_on_conflict
  ): timers_mutation_response

  """
  insert a single row into the table: "timers"
  """
  insert_timers_one(
    """the row to be inserted"""
    object: timers_insert_input!

    """on conflict condition"""
    on_conflict: timers_on_conflict
  ): timers

  """
  insert data into the table: "users"
  """
  insert_users(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """on conflict condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    """the row to be inserted"""
    object: users_insert_input!

    """on conflict condition"""
    on_conflict: users_on_conflict
  ): users

  """
  insert data into the table: "votes"
  """
  insert_votes(
    """the rows to be inserted"""
    objects: [votes_insert_input!]!

    """on conflict condition"""
    on_conflict: votes_on_conflict
  ): votes_mutation_response

  """
  insert a single row into the table: "votes"
  """
  insert_votes_one(
    """the row to be inserted"""
    object: votes_insert_input!

    """on conflict condition"""
    on_conflict: votes_on_conflict
  ): votes

  """
  update data of the table: "admissions"
  """
  update_admissions(
    """sets the columns of the filtered rows to the given values"""
    _set: admissions_set_input

    """filter the rows which have to be updated"""
    where: admissions_bool_exp!
  ): admissions_mutation_response

  """
  update single row of the table: "admissions"
  """
  update_admissions_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: admissions_set_input
    pk_columns: admissions_pk_columns_input!
  ): admissions

  """
  update data of the table: "auth.account_providers"
  """
  update_auth_account_providers(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_account_providers_set_input

    """filter the rows which have to be updated"""
    where: auth_account_providers_bool_exp!
  ): auth_account_providers_mutation_response

  """
  update single row of the table: "auth.account_providers"
  """
  update_auth_account_providers_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_account_providers_set_input
    pk_columns: auth_account_providers_pk_columns_input!
  ): auth_account_providers

  """
  update data of the table: "auth.account_roles"
  """
  update_auth_account_roles(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_account_roles_set_input

    """filter the rows which have to be updated"""
    where: auth_account_roles_bool_exp!
  ): auth_account_roles_mutation_response

  """
  update single row of the table: "auth.account_roles"
  """
  update_auth_account_roles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_account_roles_set_input
    pk_columns: auth_account_roles_pk_columns_input!
  ): auth_account_roles

  """
  update data of the table: "auth.accounts"
  """
  update_auth_accounts(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: auth_accounts_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: auth_accounts_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: auth_accounts_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: auth_accounts_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: auth_accounts_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_accounts_set_input

    """filter the rows which have to be updated"""
    where: auth_accounts_bool_exp!
  ): auth_accounts_mutation_response

  """
  update single row of the table: "auth.accounts"
  """
  update_auth_accounts_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: auth_accounts_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: auth_accounts_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: auth_accounts_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: auth_accounts_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: auth_accounts_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_accounts_set_input
    pk_columns: auth_accounts_pk_columns_input!
  ): auth_accounts

  """
  update data of the table: "auth.providers"
  """
  update_auth_providers(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_providers_set_input

    """filter the rows which have to be updated"""
    where: auth_providers_bool_exp!
  ): auth_providers_mutation_response

  """
  update single row of the table: "auth.providers"
  """
  update_auth_providers_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_providers_set_input
    pk_columns: auth_providers_pk_columns_input!
  ): auth_providers

  """
  update data of the table: "auth.refresh_tokens"
  """
  update_auth_refresh_tokens(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_refresh_tokens_set_input

    """filter the rows which have to be updated"""
    where: auth_refresh_tokens_bool_exp!
  ): auth_refresh_tokens_mutation_response

  """
  update single row of the table: "auth.refresh_tokens"
  """
  update_auth_refresh_tokens_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_refresh_tokens_set_input
    pk_columns: auth_refresh_tokens_pk_columns_input!
  ): auth_refresh_tokens

  """
  update data of the table: "auth.roles"
  """
  update_auth_roles(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_roles_set_input

    """filter the rows which have to be updated"""
    where: auth_roles_bool_exp!
  ): auth_roles_mutation_response

  """
  update single row of the table: "auth.roles"
  """
  update_auth_roles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_roles_set_input
    pk_columns: auth_roles_pk_columns_input!
  ): auth_roles

  """
  update data of the table: "authorships"
  """
  update_authorships(
    """sets the columns of the filtered rows to the given values"""
    _set: authorships_set_input

    """filter the rows which have to be updated"""
    where: authorships_bool_exp!
  ): authorships_mutation_response

  """
  update single row of the table: "authorships"
  """
  update_authorships_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: authorships_set_input
    pk_columns: authorships_pk_columns_input!
  ): authorships

  """
  update data of the table: "contents"
  """
  update_contents(
    """increments the integer columns with given value of the filtered values"""
    _inc: contents_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: contents_set_input

    """filter the rows which have to be updated"""
    where: contents_bool_exp!
  ): contents_mutation_response

  """
  update single row of the table: "contents"
  """
  update_contents_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: contents_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: contents_set_input
    pk_columns: contents_pk_columns_input!
  ): contents

  """
  update data of the table: "events"
  """
  update_events(
    """sets the columns of the filtered rows to the given values"""
    _set: events_set_input

    """filter the rows which have to be updated"""
    where: events_bool_exp!
  ): events_mutation_response

  """
  update single row of the table: "events"
  """
  update_events_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: events_set_input
    pk_columns: events_pk_columns_input!
  ): events

  """
  update data of the table: "files"
  """
  update_files(
    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input

    """filter the rows which have to be updated"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  update single row of the table: "files"
  """
  update_files_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input
    pk_columns: files_pk_columns_input!
  ): files

  """
  update data of the table: "folders"
  """
  update_folders(
    """increments the integer columns with given value of the filtered values"""
    _inc: folders_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: folders_set_input

    """filter the rows which have to be updated"""
    where: folders_bool_exp!
  ): folders_mutation_response

  """
  update single row of the table: "folders"
  """
  update_folders_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: folders_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: folders_set_input
    pk_columns: folders_pk_columns_input!
  ): folders

  """
  update data of the table: "groups"
  """
  update_groups(
    """sets the columns of the filtered rows to the given values"""
    _set: groups_set_input

    """filter the rows which have to be updated"""
    where: groups_bool_exp!
  ): groups_mutation_response

  """
  update single row of the table: "groups"
  """
  update_groups_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: groups_set_input
    pk_columns: groups_pk_columns_input!
  ): groups

  """
  update data of the table: "identities"
  """
  update_identities(
    """sets the columns of the filtered rows to the given values"""
    _set: identities_set_input

    """filter the rows which have to be updated"""
    where: identities_bool_exp!
  ): identities_mutation_response

  """
  update single row of the table: "identities"
  """
  update_identities_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: identities_set_input
    pk_columns: identities_pk_columns_input!
  ): identities

  """
  update data of the table: "memberships"
  """
  update_memberships(
    """sets the columns of the filtered rows to the given values"""
    _set: memberships_set_input

    """filter the rows which have to be updated"""
    where: memberships_bool_exp!
  ): memberships_mutation_response

  """
  update single row of the table: "memberships"
  """
  update_memberships_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: memberships_set_input
    pk_columns: memberships_pk_columns_input!
  ): memberships

  """
  update data of the table: "polls"
  """
  update_polls(
    """increments the integer columns with given value of the filtered values"""
    _inc: polls_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: polls_set_input

    """filter the rows which have to be updated"""
    where: polls_bool_exp!
  ): polls_mutation_response

  """
  update single row of the table: "polls"
  """
  update_polls_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: polls_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: polls_set_input
    pk_columns: polls_pk_columns_input!
  ): polls

  """
  update data of the table: "roles"
  """
  update_roles(
    """sets the columns of the filtered rows to the given values"""
    _set: roles_set_input

    """filter the rows which have to be updated"""
    where: roles_bool_exp!
  ): roles_mutation_response

  """
  update single row of the table: "roles"
  """
  update_roles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: roles_set_input
    pk_columns: roles_pk_columns_input!
  ): roles

  """
  update data of the table: "speakerlists"
  """
  update_speakerlists(
    """sets the columns of the filtered rows to the given values"""
    _set: speakerlists_set_input

    """filter the rows which have to be updated"""
    where: speakerlists_bool_exp!
  ): speakerlists_mutation_response

  """
  update single row of the table: "speakerlists"
  """
  update_speakerlists_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: speakerlists_set_input
    pk_columns: speakerlists_pk_columns_input!
  ): speakerlists

  """
  update data of the table: "speaks"
  """
  update_speaks(
    """increments the integer columns with given value of the filtered values"""
    _inc: speaks_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: speaks_set_input

    """filter the rows which have to be updated"""
    where: speaks_bool_exp!
  ): speaks_mutation_response

  """
  update single row of the table: "speaks"
  """
  update_speaks_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: speaks_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: speaks_set_input
    pk_columns: speaks_pk_columns_input!
  ): speaks

  """
  update data of the table: "timers"
  """
  update_timers(
    """increments the integer columns with given value of the filtered values"""
    _inc: timers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: timers_set_input

    """filter the rows which have to be updated"""
    where: timers_bool_exp!
  ): timers_mutation_response

  """
  update single row of the table: "timers"
  """
  update_timers_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: timers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: timers_set_input
    pk_columns: timers_pk_columns_input!
  ): timers

  """
  update data of the table: "users"
  """
  update_users(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update data of the table: "votes"
  """
  update_votes(
    """sets the columns of the filtered rows to the given values"""
    _set: votes_set_input

    """filter the rows which have to be updated"""
    where: votes_bool_exp!
  ): votes_mutation_response

  """
  update single row of the table: "votes"
  """
  update_votes_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: votes_set_input
    pk_columns: votes_pk_columns_input!
  ): votes
}

"""column ordering options"""
enum order_by {
  """in the ascending order, nulls last"""
  asc

  """in the ascending order, nulls first"""
  asc_nulls_first

  """in the ascending order, nulls last"""
  asc_nulls_last

  """in the descending order, nulls first"""
  desc

  """in the descending order, nulls first"""
  desc_nulls_first

  """in the descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "polls"
"""
type polls {
  active: Boolean!

  """An object relationship"""
  content: contents
  contentId: uuid!
  createdAt: timestamptz
  hidden: Boolean!
  id: uuid!
  maxVote: Int!
  minVote: Int!
  options: _text

  """An array relationship"""
  votes(
    """distinct select on columns"""
    distinct_on: [votes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [votes_order_by!]

    """filter the rows returned"""
    where: votes_bool_exp
  ): [votes!]!

  """An aggregated array relationship"""
  votes_aggregate(
    """distinct select on columns"""
    distinct_on: [votes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [votes_order_by!]

    """filter the rows returned"""
    where: votes_bool_exp
  ): votes_aggregate!
}

"""
aggregated selection of "polls"
"""
type polls_aggregate {
  aggregate: polls_aggregate_fields
  nodes: [polls!]!
}

"""
aggregate fields of "polls"
"""
type polls_aggregate_fields {
  avg: polls_avg_fields
  count(columns: [polls_select_column!], distinct: Boolean): Int
  max: polls_max_fields
  min: polls_min_fields
  stddev: polls_stddev_fields
  stddev_pop: polls_stddev_pop_fields
  stddev_samp: polls_stddev_samp_fields
  sum: polls_sum_fields
  var_pop: polls_var_pop_fields
  var_samp: polls_var_samp_fields
  variance: polls_variance_fields
}

"""
order by aggregate values of table "polls"
"""
input polls_aggregate_order_by {
  avg: polls_avg_order_by
  count: order_by
  max: polls_max_order_by
  min: polls_min_order_by
  stddev: polls_stddev_order_by
  stddev_pop: polls_stddev_pop_order_by
  stddev_samp: polls_stddev_samp_order_by
  sum: polls_sum_order_by
  var_pop: polls_var_pop_order_by
  var_samp: polls_var_samp_order_by
  variance: polls_variance_order_by
}

"""
input type for inserting array relation for remote table "polls"
"""
input polls_arr_rel_insert_input {
  data: [polls_insert_input!]!
  on_conflict: polls_on_conflict
}

"""aggregate avg on columns"""
type polls_avg_fields {
  maxVote: Float
  minVote: Float
}

"""
order by avg() on columns of table "polls"
"""
input polls_avg_order_by {
  maxVote: order_by
  minVote: order_by
}

"""
Boolean expression to filter rows from the table "polls". All fields are combined with a logical 'AND'.
"""
input polls_bool_exp {
  _and: [polls_bool_exp]
  _not: polls_bool_exp
  _or: [polls_bool_exp]
  active: Boolean_comparison_exp
  content: contents_bool_exp
  contentId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  hidden: Boolean_comparison_exp
  id: uuid_comparison_exp
  maxVote: Int_comparison_exp
  minVote: Int_comparison_exp
  options: _text_comparison_exp
  votes: votes_bool_exp
}

"""
unique or primary key constraints on table "polls"
"""
enum polls_constraint {
  """unique or primary key constraint"""
  polls_pkey
}

"""
input type for incrementing integer column in table "polls"
"""
input polls_inc_input {
  maxVote: Int
  minVote: Int
}

"""
input type for inserting data into table "polls"
"""
input polls_insert_input {
  active: Boolean
  content: contents_obj_rel_insert_input
  contentId: uuid
  createdAt: timestamptz
  hidden: Boolean
  id: uuid
  maxVote: Int
  minVote: Int
  options: _text
  votes: votes_arr_rel_insert_input
}

"""aggregate max on columns"""
type polls_max_fields {
  contentId: uuid
  createdAt: timestamptz
  id: uuid
  maxVote: Int
  minVote: Int
}

"""
order by max() on columns of table "polls"
"""
input polls_max_order_by {
  contentId: order_by
  createdAt: order_by
  id: order_by
  maxVote: order_by
  minVote: order_by
}

"""aggregate min on columns"""
type polls_min_fields {
  contentId: uuid
  createdAt: timestamptz
  id: uuid
  maxVote: Int
  minVote: Int
}

"""
order by min() on columns of table "polls"
"""
input polls_min_order_by {
  contentId: order_by
  createdAt: order_by
  id: order_by
  maxVote: order_by
  minVote: order_by
}

"""
response of any mutation on the table "polls"
"""
type polls_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [polls!]!
}

"""
input type for inserting object relation for remote table "polls"
"""
input polls_obj_rel_insert_input {
  data: polls_insert_input!
  on_conflict: polls_on_conflict
}

"""
on conflict condition type for table "polls"
"""
input polls_on_conflict {
  constraint: polls_constraint!
  update_columns: [polls_update_column!]!
  where: polls_bool_exp
}

"""
ordering options when selecting data from "polls"
"""
input polls_order_by {
  active: order_by
  content: contents_order_by
  contentId: order_by
  createdAt: order_by
  hidden: order_by
  id: order_by
  maxVote: order_by
  minVote: order_by
  options: order_by
  votes_aggregate: votes_aggregate_order_by
}

"""
primary key columns input for table: "polls"
"""
input polls_pk_columns_input {
  id: uuid!
}

"""
select columns of table "polls"
"""
enum polls_select_column {
  """column name"""
  active

  """column name"""
  contentId

  """column name"""
  createdAt

  """column name"""
  hidden

  """column name"""
  id

  """column name"""
  maxVote

  """column name"""
  minVote

  """column name"""
  options
}

"""
input type for updating data in table "polls"
"""
input polls_set_input {
  active: Boolean
  contentId: uuid
  createdAt: timestamptz
  hidden: Boolean
  id: uuid
  maxVote: Int
  minVote: Int
  options: _text
}

"""aggregate stddev on columns"""
type polls_stddev_fields {
  maxVote: Float
  minVote: Float
}

"""
order by stddev() on columns of table "polls"
"""
input polls_stddev_order_by {
  maxVote: order_by
  minVote: order_by
}

"""aggregate stddev_pop on columns"""
type polls_stddev_pop_fields {
  maxVote: Float
  minVote: Float
}

"""
order by stddev_pop() on columns of table "polls"
"""
input polls_stddev_pop_order_by {
  maxVote: order_by
  minVote: order_by
}

"""aggregate stddev_samp on columns"""
type polls_stddev_samp_fields {
  maxVote: Float
  minVote: Float
}

"""
order by stddev_samp() on columns of table "polls"
"""
input polls_stddev_samp_order_by {
  maxVote: order_by
  minVote: order_by
}

"""aggregate sum on columns"""
type polls_sum_fields {
  maxVote: Int
  minVote: Int
}

"""
order by sum() on columns of table "polls"
"""
input polls_sum_order_by {
  maxVote: order_by
  minVote: order_by
}

"""
update columns of table "polls"
"""
enum polls_update_column {
  """column name"""
  active

  """column name"""
  contentId

  """column name"""
  createdAt

  """column name"""
  hidden

  """column name"""
  id

  """column name"""
  maxVote

  """column name"""
  minVote

  """column name"""
  options
}

"""aggregate var_pop on columns"""
type polls_var_pop_fields {
  maxVote: Float
  minVote: Float
}

"""
order by var_pop() on columns of table "polls"
"""
input polls_var_pop_order_by {
  maxVote: order_by
  minVote: order_by
}

"""aggregate var_samp on columns"""
type polls_var_samp_fields {
  maxVote: Float
  minVote: Float
}

"""
order by var_samp() on columns of table "polls"
"""
input polls_var_samp_order_by {
  maxVote: order_by
  minVote: order_by
}

"""aggregate variance on columns"""
type polls_variance_fields {
  maxVote: Float
  minVote: Float
}

"""
order by variance() on columns of table "polls"
"""
input polls_variance_order_by {
  maxVote: order_by
  minVote: order_by
}

"""query root"""
type query_root {
  """
  fetch data from the table: "admissions"
  """
  admissions(
    """distinct select on columns"""
    distinct_on: [admissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admissions_order_by!]

    """filter the rows returned"""
    where: admissions_bool_exp
  ): [admissions!]!

  """
  fetch aggregated fields from the table: "admissions"
  """
  admissions_aggregate(
    """distinct select on columns"""
    distinct_on: [admissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admissions_order_by!]

    """filter the rows returned"""
    where: admissions_bool_exp
  ): admissions_aggregate!

  """fetch data from the table: "admissions" using primary key columns"""
  admissions_by_pk(id: uuid!): admissions

  """
  fetch data from the table: "auth.account_providers"
  """
  auth_account_providers(
    """distinct select on columns"""
    distinct_on: [auth_account_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_providers_order_by!]

    """filter the rows returned"""
    where: auth_account_providers_bool_exp
  ): [auth_account_providers!]!

  """
  fetch aggregated fields from the table: "auth.account_providers"
  """
  auth_account_providers_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_account_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_providers_order_by!]

    """filter the rows returned"""
    where: auth_account_providers_bool_exp
  ): auth_account_providers_aggregate!

  """
  fetch data from the table: "auth.account_providers" using primary key columns
  """
  auth_account_providers_by_pk(id: uuid!): auth_account_providers

  """
  fetch data from the table: "auth.account_roles"
  """
  auth_account_roles(
    """distinct select on columns"""
    distinct_on: [auth_account_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_roles_order_by!]

    """filter the rows returned"""
    where: auth_account_roles_bool_exp
  ): [auth_account_roles!]!

  """
  fetch aggregated fields from the table: "auth.account_roles"
  """
  auth_account_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_account_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_roles_order_by!]

    """filter the rows returned"""
    where: auth_account_roles_bool_exp
  ): auth_account_roles_aggregate!

  """
  fetch data from the table: "auth.account_roles" using primary key columns
  """
  auth_account_roles_by_pk(id: uuid!): auth_account_roles

  """
  fetch data from the table: "auth.accounts"
  """
  auth_accounts(
    """distinct select on columns"""
    distinct_on: [auth_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_accounts_order_by!]

    """filter the rows returned"""
    where: auth_accounts_bool_exp
  ): [auth_accounts!]!

  """
  fetch aggregated fields from the table: "auth.accounts"
  """
  auth_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_accounts_order_by!]

    """filter the rows returned"""
    where: auth_accounts_bool_exp
  ): auth_accounts_aggregate!

  """fetch data from the table: "auth.accounts" using primary key columns"""
  auth_accounts_by_pk(id: uuid!): auth_accounts

  """
  fetch data from the table: "auth.providers"
  """
  auth_providers(
    """distinct select on columns"""
    distinct_on: [auth_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_providers_order_by!]

    """filter the rows returned"""
    where: auth_providers_bool_exp
  ): [auth_providers!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  auth_providers_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_providers_order_by!]

    """filter the rows returned"""
    where: auth_providers_bool_exp
  ): auth_providers_aggregate!

  """fetch data from the table: "auth.providers" using primary key columns"""
  auth_providers_by_pk(provider: String!): auth_providers

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  auth_refresh_tokens(
    """distinct select on columns"""
    distinct_on: [auth_refresh_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_refresh_tokens_order_by!]

    """filter the rows returned"""
    where: auth_refresh_tokens_bool_exp
  ): [auth_refresh_tokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  auth_refresh_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_refresh_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_refresh_tokens_order_by!]

    """filter the rows returned"""
    where: auth_refresh_tokens_bool_exp
  ): auth_refresh_tokens_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  auth_refresh_tokens_by_pk(refresh_token: uuid!): auth_refresh_tokens

  """
  fetch data from the table: "auth.roles"
  """
  auth_roles(
    """distinct select on columns"""
    distinct_on: [auth_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_roles_order_by!]

    """filter the rows returned"""
    where: auth_roles_bool_exp
  ): [auth_roles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  auth_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_roles_order_by!]

    """filter the rows returned"""
    where: auth_roles_bool_exp
  ): auth_roles_aggregate!

  """fetch data from the table: "auth.roles" using primary key columns"""
  auth_roles_by_pk(role: String!): auth_roles

  """
  fetch data from the table: "authorships"
  """
  authorships(
    """distinct select on columns"""
    distinct_on: [authorships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authorships_order_by!]

    """filter the rows returned"""
    where: authorships_bool_exp
  ): [authorships!]!

  """
  fetch aggregated fields from the table: "authorships"
  """
  authorships_aggregate(
    """distinct select on columns"""
    distinct_on: [authorships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authorships_order_by!]

    """filter the rows returned"""
    where: authorships_bool_exp
  ): authorships_aggregate!

  """fetch data from the table: "authorships" using primary key columns"""
  authorships_by_pk(id: uuid!): authorships

  """
  perform the action: "canVote"
  """
  canVote(eventId: uuid): CanVoteOutput

  """
  fetch data from the table: "contents"
  """
  contents(
    """distinct select on columns"""
    distinct_on: [contents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contents_order_by!]

    """filter the rows returned"""
    where: contents_bool_exp
  ): [contents!]!

  """
  fetch aggregated fields from the table: "contents"
  """
  contents_aggregate(
    """distinct select on columns"""
    distinct_on: [contents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contents_order_by!]

    """filter the rows returned"""
    where: contents_bool_exp
  ): contents_aggregate!

  """fetch data from the table: "contents" using primary key columns"""
  contents_by_pk(id: uuid!): contents

  """
  fetch data from the table: "events"
  """
  events(
    """distinct select on columns"""
    distinct_on: [events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [events_order_by!]

    """filter the rows returned"""
    where: events_bool_exp
  ): [events!]!

  """
  fetch aggregated fields from the table: "events"
  """
  events_aggregate(
    """distinct select on columns"""
    distinct_on: [events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [events_order_by!]

    """filter the rows returned"""
    where: events_bool_exp
  ): events_aggregate!

  """fetch data from the table: "events" using primary key columns"""
  events_by_pk(id: uuid!): events

  """
  fetch data from the table: "files"
  """
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "files"
  """
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """fetch data from the table: "files" using primary key columns"""
  files_by_pk(id: uuid!): files

  """
  fetch data from the table: "folders"
  """
  folders(
    """distinct select on columns"""
    distinct_on: [folders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folders_order_by!]

    """filter the rows returned"""
    where: folders_bool_exp
  ): [folders!]!

  """
  fetch aggregated fields from the table: "folders"
  """
  folders_aggregate(
    """distinct select on columns"""
    distinct_on: [folders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folders_order_by!]

    """filter the rows returned"""
    where: folders_bool_exp
  ): folders_aggregate!

  """fetch data from the table: "folders" using primary key columns"""
  folders_by_pk(id: uuid!): folders

  """
  fetch data from the table: "groups"
  """
  groups(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): [groups!]!

  """
  fetch aggregated fields from the table: "groups"
  """
  groups_aggregate(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): groups_aggregate!

  """fetch data from the table: "groups" using primary key columns"""
  groups_by_pk(id: uuid!): groups

  """
  fetch data from the table: "identities"
  """
  identities(
    """distinct select on columns"""
    distinct_on: [identities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identities_order_by!]

    """filter the rows returned"""
    where: identities_bool_exp
  ): [identities!]!

  """
  fetch aggregated fields from the table: "identities"
  """
  identities_aggregate(
    """distinct select on columns"""
    distinct_on: [identities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identities_order_by!]

    """filter the rows returned"""
    where: identities_bool_exp
  ): identities_aggregate!

  """fetch data from the table: "identities" using primary key columns"""
  identities_by_pk(email: String!): identities

  """
  fetch data from the table: "memberships"
  """
  memberships(
    """distinct select on columns"""
    distinct_on: [memberships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [memberships_order_by!]

    """filter the rows returned"""
    where: memberships_bool_exp
  ): [memberships!]!

  """
  fetch aggregated fields from the table: "memberships"
  """
  memberships_aggregate(
    """distinct select on columns"""
    distinct_on: [memberships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [memberships_order_by!]

    """filter the rows returned"""
    where: memberships_bool_exp
  ): memberships_aggregate!

  """fetch data from the table: "memberships" using primary key columns"""
  memberships_by_pk(id: uuid!): memberships

  """
  fetch data from the table: "polls"
  """
  polls(
    """distinct select on columns"""
    distinct_on: [polls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [polls_order_by!]

    """filter the rows returned"""
    where: polls_bool_exp
  ): [polls!]!

  """
  fetch aggregated fields from the table: "polls"
  """
  polls_aggregate(
    """distinct select on columns"""
    distinct_on: [polls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [polls_order_by!]

    """filter the rows returned"""
    where: polls_bool_exp
  ): polls_aggregate!

  """fetch data from the table: "polls" using primary key columns"""
  polls_by_pk(id: uuid!): polls

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!

  """fetch data from the table: "roles" using primary key columns"""
  roles_by_pk(id: uuid!): roles

  """
  fetch data from the table: "speakerlists"
  """
  speakerlists(
    """distinct select on columns"""
    distinct_on: [speakerlists_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [speakerlists_order_by!]

    """filter the rows returned"""
    where: speakerlists_bool_exp
  ): [speakerlists!]!

  """
  fetch aggregated fields from the table: "speakerlists"
  """
  speakerlists_aggregate(
    """distinct select on columns"""
    distinct_on: [speakerlists_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [speakerlists_order_by!]

    """filter the rows returned"""
    where: speakerlists_bool_exp
  ): speakerlists_aggregate!

  """fetch data from the table: "speakerlists" using primary key columns"""
  speakerlists_by_pk(id: uuid!): speakerlists

  """
  fetch data from the table: "speaks"
  """
  speaks(
    """distinct select on columns"""
    distinct_on: [speaks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [speaks_order_by!]

    """filter the rows returned"""
    where: speaks_bool_exp
  ): [speaks!]!

  """
  fetch aggregated fields from the table: "speaks"
  """
  speaks_aggregate(
    """distinct select on columns"""
    distinct_on: [speaks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [speaks_order_by!]

    """filter the rows returned"""
    where: speaks_bool_exp
  ): speaks_aggregate!

  """fetch data from the table: "speaks" using primary key columns"""
  speaks_by_pk(id: uuid!): speaks

  """
  fetch data from the table: "timers"
  """
  timers(
    """distinct select on columns"""
    distinct_on: [timers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [timers_order_by!]

    """filter the rows returned"""
    where: timers_bool_exp
  ): [timers!]!

  """
  fetch aggregated fields from the table: "timers"
  """
  timers_aggregate(
    """distinct select on columns"""
    distinct_on: [timers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [timers_order_by!]

    """filter the rows returned"""
    where: timers_bool_exp
  ): timers_aggregate!

  """fetch data from the table: "timers" using primary key columns"""
  timers_by_pk(id: uuid!): timers

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: uuid!): users

  """
  fetch data from the table: "votes"
  """
  votes(
    """distinct select on columns"""
    distinct_on: [votes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [votes_order_by!]

    """filter the rows returned"""
    where: votes_bool_exp
  ): [votes!]!

  """
  fetch aggregated fields from the table: "votes"
  """
  votes_aggregate(
    """distinct select on columns"""
    distinct_on: [votes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [votes_order_by!]

    """filter the rows returned"""
    where: votes_bool_exp
  ): votes_aggregate!

  """fetch data from the table: "votes" using primary key columns"""
  votes_by_pk(id: uuid!): votes
}

"""
columns and relationships of "roles"
"""
type roles {
  id: uuid!

  """An object relationship"""
  membership: memberships
  membershipId: uuid!
  role: String!
}

"""
aggregated selection of "roles"
"""
type roles_aggregate {
  aggregate: roles_aggregate_fields
  nodes: [roles!]!
}

"""
aggregate fields of "roles"
"""
type roles_aggregate_fields {
  count(columns: [roles_select_column!], distinct: Boolean): Int
  max: roles_max_fields
  min: roles_min_fields
}

"""
order by aggregate values of table "roles"
"""
input roles_aggregate_order_by {
  count: order_by
  max: roles_max_order_by
  min: roles_min_order_by
}

"""
input type for inserting array relation for remote table "roles"
"""
input roles_arr_rel_insert_input {
  data: [roles_insert_input!]!
  on_conflict: roles_on_conflict
}

"""
Boolean expression to filter rows from the table "roles". All fields are combined with a logical 'AND'.
"""
input roles_bool_exp {
  _and: [roles_bool_exp]
  _not: roles_bool_exp
  _or: [roles_bool_exp]
  id: uuid_comparison_exp
  membership: memberships_bool_exp
  membershipId: uuid_comparison_exp
  role: String_comparison_exp
}

"""
unique or primary key constraints on table "roles"
"""
enum roles_constraint {
  """unique or primary key constraint"""
  roles_pkey
}

"""
input type for inserting data into table "roles"
"""
input roles_insert_input {
  id: uuid
  membership: memberships_obj_rel_insert_input
  membershipId: uuid
  role: String
}

"""aggregate max on columns"""
type roles_max_fields {
  id: uuid
  membershipId: uuid
  role: String
}

"""
order by max() on columns of table "roles"
"""
input roles_max_order_by {
  id: order_by
  membershipId: order_by
  role: order_by
}

"""aggregate min on columns"""
type roles_min_fields {
  id: uuid
  membershipId: uuid
  role: String
}

"""
order by min() on columns of table "roles"
"""
input roles_min_order_by {
  id: order_by
  membershipId: order_by
  role: order_by
}

"""
response of any mutation on the table "roles"
"""
type roles_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [roles!]!
}

"""
input type for inserting object relation for remote table "roles"
"""
input roles_obj_rel_insert_input {
  data: roles_insert_input!
  on_conflict: roles_on_conflict
}

"""
on conflict condition type for table "roles"
"""
input roles_on_conflict {
  constraint: roles_constraint!
  update_columns: [roles_update_column!]!
  where: roles_bool_exp
}

"""
ordering options when selecting data from "roles"
"""
input roles_order_by {
  id: order_by
  membership: memberships_order_by
  membershipId: order_by
  role: order_by
}

"""
primary key columns input for table: "roles"
"""
input roles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "roles"
"""
enum roles_select_column {
  """column name"""
  id

  """column name"""
  membershipId

  """column name"""
  role
}

"""
input type for updating data in table "roles"
"""
input roles_set_input {
  id: uuid
  membershipId: uuid
  role: String
}

"""
update columns of table "roles"
"""
enum roles_update_column {
  """column name"""
  id

  """column name"""
  membershipId

  """column name"""
  role
}

"""
columns and relationships of "speakerlists"
"""
type speakerlists {
  """An object relationship"""
  event: events
  eventId: uuid!
  id: uuid!
  locked: Boolean!
  name: String!

  """An array relationship"""
  speakers(
    """distinct select on columns"""
    distinct_on: [speaks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [speaks_order_by!]

    """filter the rows returned"""
    where: speaks_bool_exp
  ): [speaks!]!

  """An aggregated array relationship"""
  speakers_aggregate(
    """distinct select on columns"""
    distinct_on: [speaks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [speaks_order_by!]

    """filter the rows returned"""
    where: speaks_bool_exp
  ): speaks_aggregate!

  """An object relationship"""
  timer: timers
  timerId: uuid!
}

"""
aggregated selection of "speakerlists"
"""
type speakerlists_aggregate {
  aggregate: speakerlists_aggregate_fields
  nodes: [speakerlists!]!
}

"""
aggregate fields of "speakerlists"
"""
type speakerlists_aggregate_fields {
  count(columns: [speakerlists_select_column!], distinct: Boolean): Int
  max: speakerlists_max_fields
  min: speakerlists_min_fields
}

"""
order by aggregate values of table "speakerlists"
"""
input speakerlists_aggregate_order_by {
  count: order_by
  max: speakerlists_max_order_by
  min: speakerlists_min_order_by
}

"""
input type for inserting array relation for remote table "speakerlists"
"""
input speakerlists_arr_rel_insert_input {
  data: [speakerlists_insert_input!]!
  on_conflict: speakerlists_on_conflict
}

"""
Boolean expression to filter rows from the table "speakerlists". All fields are combined with a logical 'AND'.
"""
input speakerlists_bool_exp {
  _and: [speakerlists_bool_exp]
  _not: speakerlists_bool_exp
  _or: [speakerlists_bool_exp]
  event: events_bool_exp
  eventId: uuid_comparison_exp
  id: uuid_comparison_exp
  locked: Boolean_comparison_exp
  name: String_comparison_exp
  speakers: speaks_bool_exp
  timer: timers_bool_exp
  timerId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "speakerlists"
"""
enum speakerlists_constraint {
  """unique or primary key constraint"""
  speakerlists_pkey
}

"""
input type for inserting data into table "speakerlists"
"""
input speakerlists_insert_input {
  event: events_obj_rel_insert_input
  eventId: uuid
  id: uuid
  locked: Boolean
  name: String
  speakers: speaks_arr_rel_insert_input
  timer: timers_obj_rel_insert_input
  timerId: uuid
}

"""aggregate max on columns"""
type speakerlists_max_fields {
  eventId: uuid
  id: uuid
  name: String
  timerId: uuid
}

"""
order by max() on columns of table "speakerlists"
"""
input speakerlists_max_order_by {
  eventId: order_by
  id: order_by
  name: order_by
  timerId: order_by
}

"""aggregate min on columns"""
type speakerlists_min_fields {
  eventId: uuid
  id: uuid
  name: String
  timerId: uuid
}

"""
order by min() on columns of table "speakerlists"
"""
input speakerlists_min_order_by {
  eventId: order_by
  id: order_by
  name: order_by
  timerId: order_by
}

"""
response of any mutation on the table "speakerlists"
"""
type speakerlists_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [speakerlists!]!
}

"""
input type for inserting object relation for remote table "speakerlists"
"""
input speakerlists_obj_rel_insert_input {
  data: speakerlists_insert_input!
  on_conflict: speakerlists_on_conflict
}

"""
on conflict condition type for table "speakerlists"
"""
input speakerlists_on_conflict {
  constraint: speakerlists_constraint!
  update_columns: [speakerlists_update_column!]!
  where: speakerlists_bool_exp
}

"""
ordering options when selecting data from "speakerlists"
"""
input speakerlists_order_by {
  event: events_order_by
  eventId: order_by
  id: order_by
  locked: order_by
  name: order_by
  speakers_aggregate: speaks_aggregate_order_by
  timer: timers_order_by
  timerId: order_by
}

"""
primary key columns input for table: "speakerlists"
"""
input speakerlists_pk_columns_input {
  id: uuid!
}

"""
select columns of table "speakerlists"
"""
enum speakerlists_select_column {
  """column name"""
  eventId

  """column name"""
  id

  """column name"""
  locked

  """column name"""
  name

  """column name"""
  timerId
}

"""
input type for updating data in table "speakerlists"
"""
input speakerlists_set_input {
  eventId: uuid
  id: uuid
  locked: Boolean
  name: String
  timerId: uuid
}

"""
update columns of table "speakerlists"
"""
enum speakerlists_update_column {
  """column name"""
  eventId

  """column name"""
  id

  """column name"""
  locked

  """column name"""
  name

  """column name"""
  timerId
}

"""
columns and relationships of "speaks"
"""
type speaks {
  createdAt: timestamptz!
  id: uuid!
  priority: Int!
  speakerlistId: uuid
  type: Int!

  """An object relationship"""
  user: users
  userId: uuid!
}

"""
aggregated selection of "speaks"
"""
type speaks_aggregate {
  aggregate: speaks_aggregate_fields
  nodes: [speaks!]!
}

"""
aggregate fields of "speaks"
"""
type speaks_aggregate_fields {
  avg: speaks_avg_fields
  count(columns: [speaks_select_column!], distinct: Boolean): Int
  max: speaks_max_fields
  min: speaks_min_fields
  stddev: speaks_stddev_fields
  stddev_pop: speaks_stddev_pop_fields
  stddev_samp: speaks_stddev_samp_fields
  sum: speaks_sum_fields
  var_pop: speaks_var_pop_fields
  var_samp: speaks_var_samp_fields
  variance: speaks_variance_fields
}

"""
order by aggregate values of table "speaks"
"""
input speaks_aggregate_order_by {
  avg: speaks_avg_order_by
  count: order_by
  max: speaks_max_order_by
  min: speaks_min_order_by
  stddev: speaks_stddev_order_by
  stddev_pop: speaks_stddev_pop_order_by
  stddev_samp: speaks_stddev_samp_order_by
  sum: speaks_sum_order_by
  var_pop: speaks_var_pop_order_by
  var_samp: speaks_var_samp_order_by
  variance: speaks_variance_order_by
}

"""
input type for inserting array relation for remote table "speaks"
"""
input speaks_arr_rel_insert_input {
  data: [speaks_insert_input!]!
  on_conflict: speaks_on_conflict
}

"""aggregate avg on columns"""
type speaks_avg_fields {
  priority: Float
  type: Float
}

"""
order by avg() on columns of table "speaks"
"""
input speaks_avg_order_by {
  priority: order_by
  type: order_by
}

"""
Boolean expression to filter rows from the table "speaks". All fields are combined with a logical 'AND'.
"""
input speaks_bool_exp {
  _and: [speaks_bool_exp]
  _not: speaks_bool_exp
  _or: [speaks_bool_exp]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  priority: Int_comparison_exp
  speakerlistId: uuid_comparison_exp
  type: Int_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "speaks"
"""
enum speaks_constraint {
  """unique or primary key constraint"""
  speaks_pkey
}

"""
input type for incrementing integer column in table "speaks"
"""
input speaks_inc_input {
  priority: Int
  type: Int
}

"""
input type for inserting data into table "speaks"
"""
input speaks_insert_input {
  createdAt: timestamptz
  id: uuid
  priority: Int
  speakerlistId: uuid
  type: Int
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type speaks_max_fields {
  createdAt: timestamptz
  id: uuid
  priority: Int
  speakerlistId: uuid
  type: Int
  userId: uuid
}

"""
order by max() on columns of table "speaks"
"""
input speaks_max_order_by {
  createdAt: order_by
  id: order_by
  priority: order_by
  speakerlistId: order_by
  type: order_by
  userId: order_by
}

"""aggregate min on columns"""
type speaks_min_fields {
  createdAt: timestamptz
  id: uuid
  priority: Int
  speakerlistId: uuid
  type: Int
  userId: uuid
}

"""
order by min() on columns of table "speaks"
"""
input speaks_min_order_by {
  createdAt: order_by
  id: order_by
  priority: order_by
  speakerlistId: order_by
  type: order_by
  userId: order_by
}

"""
response of any mutation on the table "speaks"
"""
type speaks_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [speaks!]!
}

"""
input type for inserting object relation for remote table "speaks"
"""
input speaks_obj_rel_insert_input {
  data: speaks_insert_input!
  on_conflict: speaks_on_conflict
}

"""
on conflict condition type for table "speaks"
"""
input speaks_on_conflict {
  constraint: speaks_constraint!
  update_columns: [speaks_update_column!]!
  where: speaks_bool_exp
}

"""
ordering options when selecting data from "speaks"
"""
input speaks_order_by {
  createdAt: order_by
  id: order_by
  priority: order_by
  speakerlistId: order_by
  type: order_by
  user: users_order_by
  userId: order_by
}

"""
primary key columns input for table: "speaks"
"""
input speaks_pk_columns_input {
  id: uuid!
}

"""
select columns of table "speaks"
"""
enum speaks_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  priority

  """column name"""
  speakerlistId

  """column name"""
  type

  """column name"""
  userId
}

"""
input type for updating data in table "speaks"
"""
input speaks_set_input {
  createdAt: timestamptz
  id: uuid
  priority: Int
  speakerlistId: uuid
  type: Int
  userId: uuid
}

"""aggregate stddev on columns"""
type speaks_stddev_fields {
  priority: Float
  type: Float
}

"""
order by stddev() on columns of table "speaks"
"""
input speaks_stddev_order_by {
  priority: order_by
  type: order_by
}

"""aggregate stddev_pop on columns"""
type speaks_stddev_pop_fields {
  priority: Float
  type: Float
}

"""
order by stddev_pop() on columns of table "speaks"
"""
input speaks_stddev_pop_order_by {
  priority: order_by
  type: order_by
}

"""aggregate stddev_samp on columns"""
type speaks_stddev_samp_fields {
  priority: Float
  type: Float
}

"""
order by stddev_samp() on columns of table "speaks"
"""
input speaks_stddev_samp_order_by {
  priority: order_by
  type: order_by
}

"""aggregate sum on columns"""
type speaks_sum_fields {
  priority: Int
  type: Int
}

"""
order by sum() on columns of table "speaks"
"""
input speaks_sum_order_by {
  priority: order_by
  type: order_by
}

"""
update columns of table "speaks"
"""
enum speaks_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  priority

  """column name"""
  speakerlistId

  """column name"""
  type

  """column name"""
  userId
}

"""aggregate var_pop on columns"""
type speaks_var_pop_fields {
  priority: Float
  type: Float
}

"""
order by var_pop() on columns of table "speaks"
"""
input speaks_var_pop_order_by {
  priority: order_by
  type: order_by
}

"""aggregate var_samp on columns"""
type speaks_var_samp_fields {
  priority: Float
  type: Float
}

"""
order by var_samp() on columns of table "speaks"
"""
input speaks_var_samp_order_by {
  priority: order_by
  type: order_by
}

"""aggregate variance on columns"""
type speaks_variance_fields {
  priority: Float
  type: Float
}

"""
order by variance() on columns of table "speaks"
"""
input speaks_variance_order_by {
  priority: order_by
  type: order_by
}

"""subscription root"""
type subscription_root {
  """
  fetch data from the table: "admissions"
  """
  admissions(
    """distinct select on columns"""
    distinct_on: [admissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admissions_order_by!]

    """filter the rows returned"""
    where: admissions_bool_exp
  ): [admissions!]!

  """
  fetch aggregated fields from the table: "admissions"
  """
  admissions_aggregate(
    """distinct select on columns"""
    distinct_on: [admissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admissions_order_by!]

    """filter the rows returned"""
    where: admissions_bool_exp
  ): admissions_aggregate!

  """fetch data from the table: "admissions" using primary key columns"""
  admissions_by_pk(id: uuid!): admissions

  """
  fetch data from the table: "auth.account_providers"
  """
  auth_account_providers(
    """distinct select on columns"""
    distinct_on: [auth_account_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_providers_order_by!]

    """filter the rows returned"""
    where: auth_account_providers_bool_exp
  ): [auth_account_providers!]!

  """
  fetch aggregated fields from the table: "auth.account_providers"
  """
  auth_account_providers_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_account_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_providers_order_by!]

    """filter the rows returned"""
    where: auth_account_providers_bool_exp
  ): auth_account_providers_aggregate!

  """
  fetch data from the table: "auth.account_providers" using primary key columns
  """
  auth_account_providers_by_pk(id: uuid!): auth_account_providers

  """
  fetch data from the table: "auth.account_roles"
  """
  auth_account_roles(
    """distinct select on columns"""
    distinct_on: [auth_account_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_roles_order_by!]

    """filter the rows returned"""
    where: auth_account_roles_bool_exp
  ): [auth_account_roles!]!

  """
  fetch aggregated fields from the table: "auth.account_roles"
  """
  auth_account_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_account_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_roles_order_by!]

    """filter the rows returned"""
    where: auth_account_roles_bool_exp
  ): auth_account_roles_aggregate!

  """
  fetch data from the table: "auth.account_roles" using primary key columns
  """
  auth_account_roles_by_pk(id: uuid!): auth_account_roles

  """
  fetch data from the table: "auth.accounts"
  """
  auth_accounts(
    """distinct select on columns"""
    distinct_on: [auth_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_accounts_order_by!]

    """filter the rows returned"""
    where: auth_accounts_bool_exp
  ): [auth_accounts!]!

  """
  fetch aggregated fields from the table: "auth.accounts"
  """
  auth_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_accounts_order_by!]

    """filter the rows returned"""
    where: auth_accounts_bool_exp
  ): auth_accounts_aggregate!

  """fetch data from the table: "auth.accounts" using primary key columns"""
  auth_accounts_by_pk(id: uuid!): auth_accounts

  """
  fetch data from the table: "auth.providers"
  """
  auth_providers(
    """distinct select on columns"""
    distinct_on: [auth_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_providers_order_by!]

    """filter the rows returned"""
    where: auth_providers_bool_exp
  ): [auth_providers!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  auth_providers_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_providers_order_by!]

    """filter the rows returned"""
    where: auth_providers_bool_exp
  ): auth_providers_aggregate!

  """fetch data from the table: "auth.providers" using primary key columns"""
  auth_providers_by_pk(provider: String!): auth_providers

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  auth_refresh_tokens(
    """distinct select on columns"""
    distinct_on: [auth_refresh_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_refresh_tokens_order_by!]

    """filter the rows returned"""
    where: auth_refresh_tokens_bool_exp
  ): [auth_refresh_tokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  auth_refresh_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_refresh_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_refresh_tokens_order_by!]

    """filter the rows returned"""
    where: auth_refresh_tokens_bool_exp
  ): auth_refresh_tokens_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  auth_refresh_tokens_by_pk(refresh_token: uuid!): auth_refresh_tokens

  """
  fetch data from the table: "auth.roles"
  """
  auth_roles(
    """distinct select on columns"""
    distinct_on: [auth_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_roles_order_by!]

    """filter the rows returned"""
    where: auth_roles_bool_exp
  ): [auth_roles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  auth_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_roles_order_by!]

    """filter the rows returned"""
    where: auth_roles_bool_exp
  ): auth_roles_aggregate!

  """fetch data from the table: "auth.roles" using primary key columns"""
  auth_roles_by_pk(role: String!): auth_roles

  """
  fetch data from the table: "authorships"
  """
  authorships(
    """distinct select on columns"""
    distinct_on: [authorships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authorships_order_by!]

    """filter the rows returned"""
    where: authorships_bool_exp
  ): [authorships!]!

  """
  fetch aggregated fields from the table: "authorships"
  """
  authorships_aggregate(
    """distinct select on columns"""
    distinct_on: [authorships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authorships_order_by!]

    """filter the rows returned"""
    where: authorships_bool_exp
  ): authorships_aggregate!

  """fetch data from the table: "authorships" using primary key columns"""
  authorships_by_pk(id: uuid!): authorships

  """
  perform the action: "canVote"
  """
  canVote(eventId: uuid): CanVoteOutput

  """
  fetch data from the table: "contents"
  """
  contents(
    """distinct select on columns"""
    distinct_on: [contents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contents_order_by!]

    """filter the rows returned"""
    where: contents_bool_exp
  ): [contents!]!

  """
  fetch aggregated fields from the table: "contents"
  """
  contents_aggregate(
    """distinct select on columns"""
    distinct_on: [contents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contents_order_by!]

    """filter the rows returned"""
    where: contents_bool_exp
  ): contents_aggregate!

  """fetch data from the table: "contents" using primary key columns"""
  contents_by_pk(id: uuid!): contents

  """
  fetch data from the table: "events"
  """
  events(
    """distinct select on columns"""
    distinct_on: [events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [events_order_by!]

    """filter the rows returned"""
    where: events_bool_exp
  ): [events!]!

  """
  fetch aggregated fields from the table: "events"
  """
  events_aggregate(
    """distinct select on columns"""
    distinct_on: [events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [events_order_by!]

    """filter the rows returned"""
    where: events_bool_exp
  ): events_aggregate!

  """fetch data from the table: "events" using primary key columns"""
  events_by_pk(id: uuid!): events

  """
  fetch data from the table: "files"
  """
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "files"
  """
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """fetch data from the table: "files" using primary key columns"""
  files_by_pk(id: uuid!): files

  """
  fetch data from the table: "folders"
  """
  folders(
    """distinct select on columns"""
    distinct_on: [folders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folders_order_by!]

    """filter the rows returned"""
    where: folders_bool_exp
  ): [folders!]!

  """
  fetch aggregated fields from the table: "folders"
  """
  folders_aggregate(
    """distinct select on columns"""
    distinct_on: [folders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folders_order_by!]

    """filter the rows returned"""
    where: folders_bool_exp
  ): folders_aggregate!

  """fetch data from the table: "folders" using primary key columns"""
  folders_by_pk(id: uuid!): folders

  """
  fetch data from the table: "groups"
  """
  groups(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): [groups!]!

  """
  fetch aggregated fields from the table: "groups"
  """
  groups_aggregate(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): groups_aggregate!

  """fetch data from the table: "groups" using primary key columns"""
  groups_by_pk(id: uuid!): groups

  """
  fetch data from the table: "identities"
  """
  identities(
    """distinct select on columns"""
    distinct_on: [identities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identities_order_by!]

    """filter the rows returned"""
    where: identities_bool_exp
  ): [identities!]!

  """
  fetch aggregated fields from the table: "identities"
  """
  identities_aggregate(
    """distinct select on columns"""
    distinct_on: [identities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identities_order_by!]

    """filter the rows returned"""
    where: identities_bool_exp
  ): identities_aggregate!

  """fetch data from the table: "identities" using primary key columns"""
  identities_by_pk(email: String!): identities

  """
  fetch data from the table: "memberships"
  """
  memberships(
    """distinct select on columns"""
    distinct_on: [memberships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [memberships_order_by!]

    """filter the rows returned"""
    where: memberships_bool_exp
  ): [memberships!]!

  """
  fetch aggregated fields from the table: "memberships"
  """
  memberships_aggregate(
    """distinct select on columns"""
    distinct_on: [memberships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [memberships_order_by!]

    """filter the rows returned"""
    where: memberships_bool_exp
  ): memberships_aggregate!

  """fetch data from the table: "memberships" using primary key columns"""
  memberships_by_pk(id: uuid!): memberships

  """
  fetch data from the table: "polls"
  """
  polls(
    """distinct select on columns"""
    distinct_on: [polls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [polls_order_by!]

    """filter the rows returned"""
    where: polls_bool_exp
  ): [polls!]!

  """
  fetch aggregated fields from the table: "polls"
  """
  polls_aggregate(
    """distinct select on columns"""
    distinct_on: [polls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [polls_order_by!]

    """filter the rows returned"""
    where: polls_bool_exp
  ): polls_aggregate!

  """fetch data from the table: "polls" using primary key columns"""
  polls_by_pk(id: uuid!): polls

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!

  """fetch data from the table: "roles" using primary key columns"""
  roles_by_pk(id: uuid!): roles

  """
  fetch data from the table: "speakerlists"
  """
  speakerlists(
    """distinct select on columns"""
    distinct_on: [speakerlists_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [speakerlists_order_by!]

    """filter the rows returned"""
    where: speakerlists_bool_exp
  ): [speakerlists!]!

  """
  fetch aggregated fields from the table: "speakerlists"
  """
  speakerlists_aggregate(
    """distinct select on columns"""
    distinct_on: [speakerlists_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [speakerlists_order_by!]

    """filter the rows returned"""
    where: speakerlists_bool_exp
  ): speakerlists_aggregate!

  """fetch data from the table: "speakerlists" using primary key columns"""
  speakerlists_by_pk(id: uuid!): speakerlists

  """
  fetch data from the table: "speaks"
  """
  speaks(
    """distinct select on columns"""
    distinct_on: [speaks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [speaks_order_by!]

    """filter the rows returned"""
    where: speaks_bool_exp
  ): [speaks!]!

  """
  fetch aggregated fields from the table: "speaks"
  """
  speaks_aggregate(
    """distinct select on columns"""
    distinct_on: [speaks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [speaks_order_by!]

    """filter the rows returned"""
    where: speaks_bool_exp
  ): speaks_aggregate!

  """fetch data from the table: "speaks" using primary key columns"""
  speaks_by_pk(id: uuid!): speaks

  """
  fetch data from the table: "timers"
  """
  timers(
    """distinct select on columns"""
    distinct_on: [timers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [timers_order_by!]

    """filter the rows returned"""
    where: timers_bool_exp
  ): [timers!]!

  """
  fetch aggregated fields from the table: "timers"
  """
  timers_aggregate(
    """distinct select on columns"""
    distinct_on: [timers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [timers_order_by!]

    """filter the rows returned"""
    where: timers_bool_exp
  ): timers_aggregate!

  """fetch data from the table: "timers" using primary key columns"""
  timers_by_pk(id: uuid!): timers

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: uuid!): users

  """
  fetch data from the table: "votes"
  """
  votes(
    """distinct select on columns"""
    distinct_on: [votes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [votes_order_by!]

    """filter the rows returned"""
    where: votes_bool_exp
  ): [votes!]!

  """
  fetch aggregated fields from the table: "votes"
  """
  votes_aggregate(
    """distinct select on columns"""
    distinct_on: [votes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [votes_order_by!]

    """filter the rows returned"""
    where: votes_bool_exp
  ): votes_aggregate!

  """fetch data from the table: "votes" using primary key columns"""
  votes_by_pk(id: uuid!): votes
}

"""
columns and relationships of "timers"
"""
type timers {
  """An object relationship"""
  event: events
  eventId: uuid!
  id: uuid!
  time: Int!
  updatedAt: timestamptz!
}

"""
aggregated selection of "timers"
"""
type timers_aggregate {
  aggregate: timers_aggregate_fields
  nodes: [timers!]!
}

"""
aggregate fields of "timers"
"""
type timers_aggregate_fields {
  avg: timers_avg_fields
  count(columns: [timers_select_column!], distinct: Boolean): Int
  max: timers_max_fields
  min: timers_min_fields
  stddev: timers_stddev_fields
  stddev_pop: timers_stddev_pop_fields
  stddev_samp: timers_stddev_samp_fields
  sum: timers_sum_fields
  var_pop: timers_var_pop_fields
  var_samp: timers_var_samp_fields
  variance: timers_variance_fields
}

"""
order by aggregate values of table "timers"
"""
input timers_aggregate_order_by {
  avg: timers_avg_order_by
  count: order_by
  max: timers_max_order_by
  min: timers_min_order_by
  stddev: timers_stddev_order_by
  stddev_pop: timers_stddev_pop_order_by
  stddev_samp: timers_stddev_samp_order_by
  sum: timers_sum_order_by
  var_pop: timers_var_pop_order_by
  var_samp: timers_var_samp_order_by
  variance: timers_variance_order_by
}

"""
input type for inserting array relation for remote table "timers"
"""
input timers_arr_rel_insert_input {
  data: [timers_insert_input!]!
  on_conflict: timers_on_conflict
}

"""aggregate avg on columns"""
type timers_avg_fields {
  time: Float
}

"""
order by avg() on columns of table "timers"
"""
input timers_avg_order_by {
  time: order_by
}

"""
Boolean expression to filter rows from the table "timers". All fields are combined with a logical 'AND'.
"""
input timers_bool_exp {
  _and: [timers_bool_exp]
  _not: timers_bool_exp
  _or: [timers_bool_exp]
  event: events_bool_exp
  eventId: uuid_comparison_exp
  id: uuid_comparison_exp
  time: Int_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "timers"
"""
enum timers_constraint {
  """unique or primary key constraint"""
  timers_pkey
}

"""
input type for incrementing integer column in table "timers"
"""
input timers_inc_input {
  time: Int
}

"""
input type for inserting data into table "timers"
"""
input timers_insert_input {
  event: events_obj_rel_insert_input
  eventId: uuid
  id: uuid
  time: Int
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type timers_max_fields {
  eventId: uuid
  id: uuid
  time: Int
  updatedAt: timestamptz
}

"""
order by max() on columns of table "timers"
"""
input timers_max_order_by {
  eventId: order_by
  id: order_by
  time: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type timers_min_fields {
  eventId: uuid
  id: uuid
  time: Int
  updatedAt: timestamptz
}

"""
order by min() on columns of table "timers"
"""
input timers_min_order_by {
  eventId: order_by
  id: order_by
  time: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "timers"
"""
type timers_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [timers!]!
}

"""
input type for inserting object relation for remote table "timers"
"""
input timers_obj_rel_insert_input {
  data: timers_insert_input!
  on_conflict: timers_on_conflict
}

"""
on conflict condition type for table "timers"
"""
input timers_on_conflict {
  constraint: timers_constraint!
  update_columns: [timers_update_column!]!
  where: timers_bool_exp
}

"""
ordering options when selecting data from "timers"
"""
input timers_order_by {
  event: events_order_by
  eventId: order_by
  id: order_by
  time: order_by
  updatedAt: order_by
}

"""
primary key columns input for table: "timers"
"""
input timers_pk_columns_input {
  id: uuid!
}

"""
select columns of table "timers"
"""
enum timers_select_column {
  """column name"""
  eventId

  """column name"""
  id

  """column name"""
  time

  """column name"""
  updatedAt
}

"""
input type for updating data in table "timers"
"""
input timers_set_input {
  eventId: uuid
  id: uuid
  time: Int
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type timers_stddev_fields {
  time: Float
}

"""
order by stddev() on columns of table "timers"
"""
input timers_stddev_order_by {
  time: order_by
}

"""aggregate stddev_pop on columns"""
type timers_stddev_pop_fields {
  time: Float
}

"""
order by stddev_pop() on columns of table "timers"
"""
input timers_stddev_pop_order_by {
  time: order_by
}

"""aggregate stddev_samp on columns"""
type timers_stddev_samp_fields {
  time: Float
}

"""
order by stddev_samp() on columns of table "timers"
"""
input timers_stddev_samp_order_by {
  time: order_by
}

"""aggregate sum on columns"""
type timers_sum_fields {
  time: Int
}

"""
order by sum() on columns of table "timers"
"""
input timers_sum_order_by {
  time: order_by
}

"""
update columns of table "timers"
"""
enum timers_update_column {
  """column name"""
  eventId

  """column name"""
  id

  """column name"""
  time

  """column name"""
  updatedAt
}

"""aggregate var_pop on columns"""
type timers_var_pop_fields {
  time: Float
}

"""
order by var_pop() on columns of table "timers"
"""
input timers_var_pop_order_by {
  time: order_by
}

"""aggregate var_samp on columns"""
type timers_var_samp_fields {
  time: Float
}

"""
order by var_samp() on columns of table "timers"
"""
input timers_var_samp_order_by {
  time: order_by
}

"""aggregate variance on columns"""
type timers_variance_fields {
  time: Float
}

"""
order by variance() on columns of table "timers"
"""
input timers_variance_order_by {
  time: order_by
}

scalar timestamptz

"""
expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "users"
"""
type users {
  """An object relationship"""
  account: auth_accounts
  avatar_url: String
  created_at: timestamptz!
  display_name: String
  id: uuid!

  """An object relationship"""
  identity: identities
  sysAdmin: Boolean!
  updated_at: timestamptz!
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int
  max: users_max_fields
  min: users_min_fields
}

"""
order by aggregate values of table "users"
"""
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

"""
input type for inserting array relation for remote table "users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!
  on_conflict: users_on_conflict
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp]
  _not: users_bool_exp
  _or: [users_bool_exp]
  account: auth_accounts_bool_exp
  avatar_url: String_comparison_exp
  created_at: timestamptz_comparison_exp
  display_name: String_comparison_exp
  id: uuid_comparison_exp
  identity: identities_bool_exp
  sysAdmin: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """unique or primary key constraint"""
  users_pkey
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  account: auth_accounts_obj_rel_insert_input
  avatar_url: String
  created_at: timestamptz
  display_name: String
  id: uuid
  identity: identities_obj_rel_insert_input
  sysAdmin: Boolean
  updated_at: timestamptz
}

"""aggregate max on columns"""
type users_max_fields {
  avatar_url: String
  created_at: timestamptz
  display_name: String
  id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "users"
"""
input users_max_order_by {
  avatar_url: order_by
  created_at: order_by
  display_name: order_by
  id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type users_min_fields {
  avatar_url: String
  created_at: timestamptz
  display_name: String
  id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "users"
"""
input users_min_order_by {
  avatar_url: order_by
  created_at: order_by
  display_name: order_by
  id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!
  on_conflict: users_on_conflict
}

"""
on conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]!
  where: users_bool_exp
}

"""
ordering options when selecting data from "users"
"""
input users_order_by {
  account: auth_accounts_order_by
  avatar_url: order_by
  created_at: order_by
  display_name: order_by
  id: order_by
  identity: identities_order_by
  sysAdmin: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "users"
"""
input users_pk_columns_input {
  id: uuid!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """column name"""
  avatar_url

  """column name"""
  created_at

  """column name"""
  display_name

  """column name"""
  id

  """column name"""
  sysAdmin

  """column name"""
  updated_at
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  avatar_url: String
  created_at: timestamptz
  display_name: String
  id: uuid
  sysAdmin: Boolean
  updated_at: timestamptz
}

"""
update columns of table "users"
"""
enum users_update_column {
  """column name"""
  avatar_url

  """column name"""
  created_at

  """column name"""
  display_name

  """column name"""
  id

  """column name"""
  sysAdmin

  """column name"""
  updated_at
}

scalar uuid

"""
expression to compare columns of type uuid. All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "votes"
"""
type votes {
  id: uuid!
  pollId: uuid!
  userId: uuid!
  value: _int4!
}

"""
aggregated selection of "votes"
"""
type votes_aggregate {
  aggregate: votes_aggregate_fields
  nodes: [votes!]!
}

"""
aggregate fields of "votes"
"""
type votes_aggregate_fields {
  count(columns: [votes_select_column!], distinct: Boolean): Int
  max: votes_max_fields
  min: votes_min_fields
}

"""
order by aggregate values of table "votes"
"""
input votes_aggregate_order_by {
  count: order_by
  max: votes_max_order_by
  min: votes_min_order_by
}

"""
input type for inserting array relation for remote table "votes"
"""
input votes_arr_rel_insert_input {
  data: [votes_insert_input!]!
  on_conflict: votes_on_conflict
}

"""
Boolean expression to filter rows from the table "votes". All fields are combined with a logical 'AND'.
"""
input votes_bool_exp {
  _and: [votes_bool_exp]
  _not: votes_bool_exp
  _or: [votes_bool_exp]
  id: uuid_comparison_exp
  pollId: uuid_comparison_exp
  userId: uuid_comparison_exp
  value: _int4_comparison_exp
}

"""
unique or primary key constraints on table "votes"
"""
enum votes_constraint {
  """unique or primary key constraint"""
  votes_pkey

  """unique or primary key constraint"""
  votes_pollId_userId_key
}

"""
input type for inserting data into table "votes"
"""
input votes_insert_input {
  id: uuid
  pollId: uuid
  userId: uuid
  value: _int4
}

"""aggregate max on columns"""
type votes_max_fields {
  id: uuid
  pollId: uuid
  userId: uuid
}

"""
order by max() on columns of table "votes"
"""
input votes_max_order_by {
  id: order_by
  pollId: order_by
  userId: order_by
}

"""aggregate min on columns"""
type votes_min_fields {
  id: uuid
  pollId: uuid
  userId: uuid
}

"""
order by min() on columns of table "votes"
"""
input votes_min_order_by {
  id: order_by
  pollId: order_by
  userId: order_by
}

"""
response of any mutation on the table "votes"
"""
type votes_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [votes!]!
}

"""
input type for inserting object relation for remote table "votes"
"""
input votes_obj_rel_insert_input {
  data: votes_insert_input!
  on_conflict: votes_on_conflict
}

"""
on conflict condition type for table "votes"
"""
input votes_on_conflict {
  constraint: votes_constraint!
  update_columns: [votes_update_column!]!
  where: votes_bool_exp
}

"""
ordering options when selecting data from "votes"
"""
input votes_order_by {
  id: order_by
  pollId: order_by
  userId: order_by
  value: order_by
}

"""
primary key columns input for table: "votes"
"""
input votes_pk_columns_input {
  id: uuid!
}

"""
select columns of table "votes"
"""
enum votes_select_column {
  """column name"""
  id

  """column name"""
  pollId

  """column name"""
  userId

  """column name"""
  value
}

"""
input type for updating data in table "votes"
"""
input votes_set_input {
  id: uuid
  pollId: uuid
  userId: uuid
  value: _int4
}

"""
update columns of table "votes"
"""
enum votes_update_column {
  """column name"""
  id

  """column name"""
  pollId

  """column name"""
  userId

  """column name"""
  value
}

